#!/usr/bin/env bash
#
# apr - Automated Plan Reviser Pro (v1.1.0)
# Iterative specification refinement with GPT Pro Extended Reasoning via Oracle
#
# FEATURES:
#   - Beautiful gum-based terminal UI with graceful ANSI fallback
#   - Interactive workflow setup wizard
#   - Multi-round revision tracking with git integration
#   - GPT Pro 5.2 Extended Reasoning via Oracle browser automation
#   - Session monitoring and reattachment
#   - Configurable document bundles (README, spec, implementation)
#   - Automatic round output management and history tracking
#   - Self-update with checksum verification
#   - Daily update checking (opt-in)
#
# Usage:
#   apr [command] [options]
#
# Commands:
#   run <round>        Run a revision round (default command)
#   setup              Interactive workflow setup wizard
#   status             Check Oracle session status
#   attach <session>   Attach to a running/completed session
#   list               List all configured workflows
#   history            Show revision history for current workflow
#   update             Check for and install updates
#   help               Show help message
#
# Options:
#   -w, --workflow     Workflow name (default: from .apr/config.yaml or 'default')
#   -i, --include-impl Include implementation document
#   -d, --dry-run      Preview without sending to GPT Pro
#   -r, --render       Render bundle for manual paste
#   -c, --copy         Copy rendered bundle to clipboard
#   --wait             Wait for completion (blocking)
#   --login            Manual login mode (first-time setup)
#   --keep-browser     Keep browser open after completion
#   --no-preflight     Skip pre-flight checks (not recommended)
#   --retry            Enable Oracle retries (default)
#   --no-retry         Disable Oracle retries
#   -q, --quiet        Minimal output (errors only)
#   -v, --verbose      Verbose logging (debug)
#   --version          Show version
#
# Environment Variables:
#   APR_HOME           Data directory (default: ~/.local/share/apr)
#   APR_CACHE          Cache directory (default: ~/.cache/apr)
#   APR_CHECK_UPDATES  Enable daily update check (set to 1)
#   APR_NO_GUM         Disable gum even if available
#   NO_COLOR           Disable colors (accessibility)
#
# More info: https://github.com/Dicklesworthstone/automated_plan_reviser_pro

set -euo pipefail

VERSION="1.1.0"

# GitHub repository info for updates
readonly REPO_OWNER="Dicklesworthstone"
readonly REPO_NAME="automated_plan_reviser_pro"
readonly GITHUB_RAW="https://raw.githubusercontent.com"
readonly VERSION_URL="${GITHUB_RAW}/${REPO_OWNER}/${REPO_NAME}/main/VERSION"
readonly RELEASES_URL="https://github.com/${REPO_OWNER}/${REPO_NAME}/releases"

# -----------------------------------------------------------------------------
# Exit Codes (semantic, non-contiguous for future additions)
# -----------------------------------------------------------------------------
readonly EXIT_SUCCESS=0
# shellcheck disable=SC2034  # Reserved for future use
readonly EXIT_PARTIAL_FAILURE=1   # Some operations failed
readonly EXIT_USAGE_ERROR=2       # Bad arguments
readonly EXIT_DEPENDENCY_ERROR=3  # Missing Oracle, Node.js, etc.
readonly EXIT_CONFIG_ERROR=4      # Invalid config, missing files
readonly EXIT_NETWORK_ERROR=10    # Timeout, DNS, unreachable
readonly EXIT_UPDATE_ERROR=11     # Self-update failed

# -----------------------------------------------------------------------------
# Colors (conditional on TTY and NO_COLOR)
# -----------------------------------------------------------------------------
# Respect NO_COLOR environment variable for accessibility
# Check stderr (-t 2) since all log output goes there
if [[ -t 2 ]] && [[ -z "${NO_COLOR:-}" ]]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    CYAN='\033[0;36m'
    MAGENTA='\033[0;35m'
    WHITE='\033[1;37m'
    BOLD='\033[1m'
    DIM='\033[2m'
    NC='\033[0m'
else
    RED='' GREEN='' YELLOW='' CYAN='' MAGENTA='' WHITE='' BOLD='' DIM='' NC=''
fi

# Gum availability flag
GUM_AVAILABLE=false

# Quiet mode flag
QUIET_MODE=false

# Verbose mode flag (for debugging)
VERBOSE="${APR_VERBOSE:-false}"

# Configuration (XDG-compliant with overrides)
APR_HOME="${APR_HOME:-${XDG_DATA_HOME:-$HOME/.local/share}/apr}"
APR_CACHE="${APR_CACHE:-${XDG_CACHE_HOME:-$HOME/.cache}/apr}"
CONFIG_DIR=".apr"

# Oracle command (determined at runtime)
ORACLE_CMD=""

# Temp directory for cleanup on exit
APR_TEMP_DIR=""

# Cleanup function for trap
cleanup_temp() {
    # Release any held lock
    release_lock 2>/dev/null || true
    # Remove temp directory
    if [[ -n "$APR_TEMP_DIR" && -d "$APR_TEMP_DIR" ]]; then
        rm -rf "$APR_TEMP_DIR"
    fi
}

# Set trap for cleanup on exit/interrupt
trap cleanup_temp EXIT INT TERM

# Lock file path (set when acquired)
APR_LOCK_FILE=""
APR_LOCK_FD=""

# Acquire a lock for a workflow/round to prevent concurrent runs
# Usage: acquire_lock workflow round
# Returns: 0 if acquired, 1 if already locked
acquire_lock() {
    local workflow="$1"
    local round="$2"
    local lock_dir="$CONFIG_DIR/.locks"
    mkdir -p "$lock_dir" 2>/dev/null

    APR_LOCK_FILE="$lock_dir/${workflow}_round_${round}.lock"

    # Use flock if available (preferred - atomic and robust)
    if command -v flock &>/dev/null; then
        exec {APR_LOCK_FD}>"$APR_LOCK_FILE"
        if ! flock -n "$APR_LOCK_FD"; then
            return 1
        fi
        echo "$$" >&"$APR_LOCK_FD"
    else
        # Fallback: simple file-based locking
        if [[ -f "$APR_LOCK_FILE" ]]; then
            local pid
            pid=$(cat "$APR_LOCK_FILE" 2>/dev/null || echo "")
            # Check if the process is still running
            if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
                return 1
            fi
            # Stale lock file - remove it
            rm -f "$APR_LOCK_FILE"
        fi
        echo "$$" > "$APR_LOCK_FILE"
    fi
    return 0
}

# Release the lock
release_lock() {
    if [[ -n "$APR_LOCK_FD" ]]; then
        exec {APR_LOCK_FD}>&-
        APR_LOCK_FD=""
    fi
    if [[ -n "$APR_LOCK_FILE" && -f "$APR_LOCK_FILE" ]]; then
        rm -f "$APR_LOCK_FILE"
        APR_LOCK_FILE=""
    fi
}

# -----------------------------------------------------------------------------
# Utility Functions
# -----------------------------------------------------------------------------

# Compare semantic versions. Returns 0 if $1 > $2
version_gt() {
    local v1="$1" v2="$2"
    if command -v sort &> /dev/null && printf '%s\n' "$v1" "$v2" | sort -V &>/dev/null; then
        [[ "$(printf '%s\n' "$v1" "$v2" | sort -V | tail -n1)" == "$v1" && "$v1" != "$v2" ]]
    else
        # Fallback to string comparison
        [[ "$v1" > "$v2" ]]
    fi
}

# Check if we can prompt the user (interactive terminal)
can_prompt() {
    [[ -t 0 && -t 2 && "$QUIET_MODE" != "true" ]]
}

# -----------------------------------------------------------------------------
# Update Checking (Opt-In)
# -----------------------------------------------------------------------------

check_for_updates() {
    # Only check if explicitly enabled
    [[ -z "${APR_CHECK_UPDATES:-}" ]] && return 0

    local check_file="${APR_HOME}/.last_update_check"
    local one_day=86400

    # Ensure directory exists
    mkdir -p "$APR_HOME" 2>/dev/null || true

    # Check if we already checked today
    if [[ -f "$check_file" ]]; then
        local last_check now
        last_check=$(cat "$check_file" 2>/dev/null || echo "0")
        now=$(date +%s)
        if (( now - last_check < one_day )); then
            return 0  # Skip - already checked today
        fi
    fi

    # Show progress indicator if interactive
    [[ "$QUIET_MODE" != "true" ]] && print_dim "Checking for updates..." >&2

    # Fetch remote version with short timeout
    local remote_version=""
    if command -v curl &> /dev/null; then
        remote_version=$(curl -fsSL --connect-timeout 2 --max-time 5 "$VERSION_URL" 2>/dev/null | tr -d '[:space:]') || true
    elif command -v wget &> /dev/null; then
        remote_version=$(wget -q --timeout=5 -O - "$VERSION_URL" 2>/dev/null | tr -d '[:space:]') || true
    fi

    # Update timestamp regardless of result
    date +%s > "$check_file" 2>/dev/null || true

    # Compare versions and notify if update available
    if [[ -n "$remote_version" && "$remote_version" != "$VERSION" ]]; then
        if version_gt "$remote_version" "$VERSION"; then
            echo -e "${YELLOW}[apr]${NC} Update available: ${VERSION} → ${remote_version}" >&2
            echo -e "${DIM}      Run 'apr update' to install${NC}" >&2
        fi
    fi
}

# -----------------------------------------------------------------------------
# Self-Update Command
# -----------------------------------------------------------------------------

cmd_update() {
    print_banner

    print_header "CHECKING FOR UPDATES"
    echo "" >&2

    # Fetch latest version
    print_info "Fetching latest version info..."
    local remote_version=""
    if command -v curl &> /dev/null; then
        remote_version=$(curl -fsSL --connect-timeout 5 --max-time 10 "$VERSION_URL" 2>/dev/null | tr -d '[:space:]') || true
    elif command -v wget &> /dev/null; then
        remote_version=$(wget -q --timeout=10 -O - "$VERSION_URL" 2>/dev/null | tr -d '[:space:]') || true
    fi

    if [[ -z "$remote_version" ]]; then
        print_error "Failed to check for updates (network error)"
        exit $EXIT_NETWORK_ERROR
    fi

    if [[ "$remote_version" == "$VERSION" ]]; then
        print_success "Already up to date (v${VERSION})"
        exit $EXIT_SUCCESS
    fi

    if ! version_gt "$remote_version" "$VERSION"; then
        print_info "Current version (v${VERSION}) is newer than remote (v${remote_version})"
        exit $EXIT_SUCCESS
    fi

    print_info "Update available: v${VERSION} → v${remote_version}"
    echo "" >&2

    # Prompt for confirmation if interactive
    if can_prompt; then
        if ! confirm "Install update?"; then
            print_info "Update cancelled"
            exit $EXIT_SUCCESS
        fi
    fi

    # Create temp directory (uses global for cleanup trap)
    APR_TEMP_DIR=$(mktemp -d 2>/dev/null || mktemp -d -t apr 2>/dev/null)
    if [[ -z "$APR_TEMP_DIR" || ! -d "$APR_TEMP_DIR" ]]; then
        print_error "Failed to create temp directory"
        exit $EXIT_UPDATE_ERROR
    fi
    local tmp_dir="$APR_TEMP_DIR"

    # Download new version
    print_info "Downloading v${remote_version}..."
    local download_url="${RELEASES_URL}/download/v${remote_version}/apr"
    local checksum_url="${RELEASES_URL}/download/v${remote_version}/apr.sha256"

    if command -v curl &> /dev/null; then
        curl -fsSL "$download_url" -o "$tmp_dir/apr" 2>/dev/null || {
            # Fallback to main branch if no release
            curl -fsSL "${GITHUB_RAW}/${REPO_OWNER}/${REPO_NAME}/main/apr" -o "$tmp_dir/apr" 2>/dev/null
        }
    elif command -v wget &> /dev/null; then
        wget -q "$download_url" -O "$tmp_dir/apr" 2>/dev/null || {
            wget -q "${GITHUB_RAW}/${REPO_OWNER}/${REPO_NAME}/main/apr" -O "$tmp_dir/apr" 2>/dev/null
        }
    fi

    if [[ ! -s "$tmp_dir/apr" ]]; then
        print_error "Failed to download update"
        rm -rf "$tmp_dir"
        exit $EXIT_UPDATE_ERROR
    fi

    # Verify it's a bash script (security check)
    local first_line=""
    IFS= read -r first_line < "$tmp_dir/apr" 2>/dev/null || true
    # Accept any valid bash shebang: #!/bin/bash, #!/usr/bin/env bash, etc.
    if [[ ! "$first_line" =~ ^#!.*bash ]]; then
        print_error "Downloaded file is not a valid apr script"
        print_dim "Expected bash shebang, got: $first_line"
        rm -rf "$tmp_dir"
        exit $EXIT_UPDATE_ERROR
    fi

    # Try to verify checksum (non-fatal if checksums not available)
    # Checksum file may be: just hash, or "hash  filename" (sha256sum format)
    local expected_checksum="" raw_checksum=""
    if command -v curl &> /dev/null; then
        raw_checksum=$(curl -fsSL "$checksum_url" 2>/dev/null) || true
    elif command -v wget &> /dev/null; then
        raw_checksum=$(wget -q -O - "$checksum_url" 2>/dev/null) || true
    fi
    # Extract just the hash (first field if space-separated, otherwise whole string)
    expected_checksum=$(echo "$raw_checksum" | awk '{print $1}' | tr -d '[:space:]')

    if [[ -n "$expected_checksum" ]]; then
        print_info "Verifying checksum..."
        local actual_checksum=""
        if command -v sha256sum &> /dev/null; then
            actual_checksum=$(sha256sum "$tmp_dir/apr" | cut -d' ' -f1)
        elif command -v shasum &> /dev/null; then
            actual_checksum=$(shasum -a 256 "$tmp_dir/apr" | cut -d' ' -f1)
        fi

        if [[ -n "$actual_checksum" && "$actual_checksum" != "$expected_checksum" ]]; then
            print_error "Checksum verification failed!"
            print_error "Expected: $expected_checksum"
            print_error "Got:      $actual_checksum"
            rm -rf "$tmp_dir"
            exit $EXIT_UPDATE_ERROR
        fi
        print_success "Checksum verified"
    else
        print_warning "Checksum not available (installing from main branch)"
    fi

    # Find where we're installed
    local script_path="${BASH_SOURCE[0]}"
    script_path=$(realpath "$script_path" 2>/dev/null || readlink -f "$script_path" 2>/dev/null || echo "$script_path")

    # Install update
    print_info "Installing to $script_path..."
    chmod +x "$tmp_dir/apr"

    if [[ -w "$script_path" ]]; then
        mv "$tmp_dir/apr" "$script_path"
    elif command -v sudo &> /dev/null; then
        sudo mv "$tmp_dir/apr" "$script_path"
    else
        print_error "Cannot write to $script_path (try running with sudo)"
        rm -rf "$tmp_dir"
        exit $EXIT_UPDATE_ERROR
    fi

    rm -rf "$tmp_dir"
    APR_TEMP_DIR=""  # Clear for trap
    print_success "Updated to v${remote_version}!"
}

# -----------------------------------------------------------------------------
# Gum Installation & Detection
# -----------------------------------------------------------------------------

try_install_gum() {
    local os="unknown"
    case "$(uname -s)" in
        Darwin*) os="macos" ;;
        Linux*)  os="linux" ;;
    esac

    case "$os" in
        macos)
            if command -v brew &> /dev/null; then
                brew install gum &>/dev/null && return 0
            fi
            ;;
        linux)
            if command -v apt-get &> /dev/null; then
                (
                    sudo mkdir -p /etc/apt/keyrings 2>/dev/null
                    curl -fsSL https://repo.charm.sh/apt/gpg.key | sudo gpg --dearmor -o /etc/apt/keyrings/charm.gpg 2>/dev/null
                    echo "deb [signed-by=/etc/apt/keyrings/charm.gpg] https://repo.charm.sh/apt/ * *" | sudo tee /etc/apt/sources.list.d/charm.list >/dev/null
                    sudo apt-get update -qq && sudo apt-get install -y -qq gum
                ) &>/dev/null && return 0
            elif command -v dnf &> /dev/null; then
                (
                    echo '[charm]
name=Charm
baseurl=https://repo.charm.sh/yum/
enabled=1
gpgcheck=1
gpgkey=https://repo.charm.sh/yum/gpg.key' | sudo tee /etc/yum.repos.d/charm.repo >/dev/null
                    sudo dnf install -y gum
                ) &>/dev/null && return 0
            elif command -v pacman &> /dev/null; then
                sudo pacman -S --noconfirm gum &>/dev/null && return 0
            fi

            # Fallback: GitHub releases
            local arch
            arch=$(uname -m)
            case "$arch" in
                x86_64) arch="amd64" ;;
                aarch64|arm64) arch="arm64" ;;
                *) return 1 ;;
            esac

            local tmp_dir gum_version="0.14.5"
            tmp_dir=$(mktemp -d)
            local gum_url="https://github.com/charmbracelet/gum/releases/download/v${gum_version}/gum_${gum_version}_Linux_${arch}.tar.gz"

            (
                cd "$tmp_dir"
                curl -fsSL "$gum_url" -o gum.tar.gz
                tar -xzf gum.tar.gz
                sudo mv gum /usr/local/bin/gum 2>/dev/null || {
                    mkdir -p ~/.local/bin
                    mv gum ~/.local/bin/gum
                }
            ) &>/dev/null && rm -rf "$tmp_dir" && return 0

            rm -rf "$tmp_dir"
            ;;
    esac

    return 1
}

check_gum() {
    # Respect APR_NO_GUM
    [[ -n "${APR_NO_GUM:-}" ]] && return 1

    if command -v gum &> /dev/null; then
        GUM_AVAILABLE=true
        return 0
    fi

    # Only try to install if interactive and not in CI
    # Check stderr (-t 2) since APR outputs to stderr
    if [[ -t 2 && -z "${CI:-}" ]]; then
        if try_install_gum; then
            if [[ -x "${HOME}/.local/bin/gum" && ":$PATH:" != *":${HOME}/.local/bin:"* ]]; then
                export PATH="${HOME}/.local/bin:${PATH}"
            fi
            if command -v gum &> /dev/null; then
                GUM_AVAILABLE=true
                return 0
            fi
        fi
    fi

    return 1
}

# -----------------------------------------------------------------------------
# Oracle Detection
# -----------------------------------------------------------------------------

check_oracle() {
    if command -v oracle &> /dev/null; then
        ORACLE_CMD="oracle"
        return 0
    elif command -v npx &> /dev/null; then
        ORACLE_CMD="npx -y @steipete/oracle"
        return 0
    else
        return 1
    fi
}

# -----------------------------------------------------------------------------
# Pre-flight Oracle Validation
# -----------------------------------------------------------------------------

# Run pre-flight checks before expensive Oracle runs
# Usage: preflight_check readme_path spec_path [impl_path]
# Returns: 0 if all checks pass, 1 if critical failure, 2 if warning only
preflight_check() {
    local readme_path="$1"
    local spec_path="$2"
    local impl_path="${3:-}"
    local has_warnings=false

    verbose "preflight_check: readme=$readme_path spec=$spec_path impl=${impl_path:-<none>}"

    print_info "Running pre-flight checks..."

    # Check Oracle availability
    if ! check_oracle; then
        print_error "Pre-flight failed: Oracle not available"
        return 1
    fi
    verbose "preflight: Oracle available via $ORACLE_CMD"

    # Try to check Oracle health (quick version check)
    local oracle_version=""
    if oracle_version=$($ORACLE_CMD --version 2>/dev/null); then
        verbose "preflight: Oracle version: $oracle_version"
        print_success "Oracle available ($oracle_version)"
    else
        print_warning "Could not verify Oracle version (may still work)"
        has_warnings=true
    fi

    # Check source files exist and are readable
    if [[ ! -f "$readme_path" ]]; then
        print_error "Pre-flight failed: README not found: $readme_path"
        return 1
    fi
    if [[ ! -r "$readme_path" ]]; then
        print_error "Pre-flight failed: README not readable: $readme_path"
        return 1
    fi
    local readme_size
    readme_size=$(du -h "$readme_path" 2>/dev/null | cut -f1)
    verbose "preflight: README exists: $readme_path ($readme_size)"
    print_success "README: $readme_path ($readme_size)"

    if [[ ! -f "$spec_path" ]]; then
        print_error "Pre-flight failed: Spec not found: $spec_path"
        return 1
    fi
    if [[ ! -r "$spec_path" ]]; then
        print_error "Pre-flight failed: Spec not readable: $spec_path"
        return 1
    fi
    local spec_size
    spec_size=$(du -h "$spec_path" 2>/dev/null | cut -f1)
    verbose "preflight: Spec exists: $spec_path ($spec_size)"
    print_success "Spec: $spec_path ($spec_size)"

    # Check implementation file if provided
    if [[ -n "$impl_path" ]]; then
        if [[ ! -f "$impl_path" ]]; then
            print_warning "Implementation not found: $impl_path (will be skipped)"
            has_warnings=true
        elif [[ ! -r "$impl_path" ]]; then
            print_warning "Implementation not readable: $impl_path (will be skipped)"
            has_warnings=true
        else
            local impl_size
            impl_size=$(du -h "$impl_path" 2>/dev/null | cut -f1)
            verbose "preflight: Implementation exists: $impl_path ($impl_size)"
            print_success "Implementation: $impl_path ($impl_size)"
        fi
    fi

    echo "" >&2
    if [[ "$has_warnings" == "true" ]]; then
        print_warning "Pre-flight completed with warnings"
        return 2
    else
        print_success "All pre-flight checks passed"
        return 0
    fi
}

# -----------------------------------------------------------------------------
# Auto-Retry with Exponential Backoff
# -----------------------------------------------------------------------------

# Maximum retry attempts
MAX_RETRY_ATTEMPTS="${APR_MAX_RETRIES:-3}"
# Initial backoff in seconds
INITIAL_BACKOFF="${APR_INITIAL_BACKOFF:-10}"

# Run Oracle with auto-retry on transient failures
# Usage: run_oracle_with_retry oracle_args...
# Returns: Oracle exit code
run_oracle_with_retry() {
    local attempt=1
    local backoff="$INITIAL_BACKOFF"
    local exit_code=0

    verbose "run_oracle_with_retry: max_attempts=$MAX_RETRY_ATTEMPTS initial_backoff=$INITIAL_BACKOFF"

    while [[ $attempt -le $MAX_RETRY_ATTEMPTS ]]; do
        verbose "Oracle attempt $attempt/$MAX_RETRY_ATTEMPTS"

        # Run Oracle command
        set +e
        $ORACLE_CMD "$@"
        exit_code=$?
        set -e

        verbose "Oracle attempt $attempt exit_code=$exit_code"

        # Success - return immediately
        if [[ $exit_code -eq 0 ]]; then
            return 0
        fi

        # Check if this is a retryable error
        # Exit codes: typically network/transient issues are specific codes
        # For now, we'll retry on any non-zero exit if we have attempts left
        if [[ $attempt -lt $MAX_RETRY_ATTEMPTS ]]; then
            print_warning "Attempt $attempt/$MAX_RETRY_ATTEMPTS failed (exit code: $exit_code)"
            print_info "Retrying in ${backoff}s..."
            sleep "$backoff"
            # Exponential backoff: 10s, 30s, 90s
            backoff=$((backoff * 3))
        fi

        ((attempt++))
    done

    print_error "All $MAX_RETRY_ATTEMPTS attempts failed"
    return "$exit_code"
}

# -----------------------------------------------------------------------------
# Styled Output Functions
# -----------------------------------------------------------------------------

print_banner() {
    [[ "$QUIET_MODE" == "true" ]] && return

    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        gum style \
            --border double \
            --border-foreground 212 \
            --padding "0 2" \
            --margin "1 0" \
            --bold \
            --foreground 212 \
            "  Automated Plan Reviser Pro v${VERSION}" \
            "  Iterative AI-Powered Spec Refinement" >&2
    else
        # Get terminal width, default to 60 if unavailable
        local term_width
        term_width=$(tput cols 2>/dev/null || echo "60")
        # Cap at 60 for aesthetics
        (( term_width > 60 )) && term_width=60
        # Minimum width for readability
        (( term_width < 40 )) && term_width=40

        # Generate border of appropriate width
        local border=""
        for ((i=0; i<term_width; i++)); do
            border+="━"
        done

        echo "" >&2
        echo -e "${BOLD}${MAGENTA}${border}${NC}" >&2
        echo -e "  ${BOLD}${WHITE}Automated Plan Reviser Pro${NC} ${DIM}v${VERSION}${NC}" >&2
        echo -e "  ${DIM}Iterative AI-Powered Spec Refinement${NC}" >&2
        echo -e "${BOLD}${MAGENTA}${border}${NC}" >&2
        echo "" >&2
    fi
}

print_header() {
    [[ "$QUIET_MODE" == "true" ]] && return
    local text="$1"
    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        gum style --foreground 214 --bold "$text" >&2
    else
        echo -e "${BOLD}${YELLOW}$text${NC}" >&2
    fi
}

print_success() {
    [[ "$QUIET_MODE" == "true" ]] && return
    local text="$1"
    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        gum style --foreground 82 "✓ $text" >&2
    else
        echo -e "${GREEN}✓${NC} $text" >&2
    fi
}

print_error() {
    local text="$1"
    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        gum style --foreground 196 "✗ $text" >&2
    else
        echo -e "${RED}✗${NC} $text" >&2
    fi
}

print_warning() {
    local text="$1"
    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        gum style --foreground 214 "⚠ $text" >&2
    else
        echo -e "${YELLOW}⚠${NC} $text" >&2
    fi
}

print_info() {
    [[ "$QUIET_MODE" == "true" ]] && return
    local text="$1"
    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        gum style --foreground 39 "ℹ $text" >&2
    else
        echo -e "${CYAN}ℹ${NC} $text" >&2
    fi
}

print_dim() {
    [[ "$QUIET_MODE" == "true" ]] && return
    local text="$1"
    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        gum style --faint "$text" >&2
    else
        echo -e "${DIM}$text${NC}" >&2
    fi
}

# Verbose logging (only shown when VERBOSE=true or --verbose flag)
verbose() {
    [[ "$VERBOSE" != "true" ]] && return
    echo -e "${DIM}[apr:verbose]${NC} $*" >&2
}

print_step() {
    [[ "$QUIET_MODE" == "true" ]] && return
    local step="$1"
    local total="$2"
    local text="$3"
    local optional="${4:-}"  # Pass "optional" for optional steps

    local step_label="[$step/$total]"
    if [[ "$optional" == "optional" ]]; then
        step_label="[Optional]"
    fi

    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        echo "$(gum style --foreground 212 --bold "$step_label") $(gum style --faint "$text")" >&2
    else
        echo -e "${BOLD}${MAGENTA}${step_label}${NC} ${DIM}$text${NC}" >&2
    fi
}

spin() {
    local text="$1"
    shift
    if [[ "$GUM_AVAILABLE" == "true" && "$QUIET_MODE" != "true" ]]; then
        gum spin --spinner dot --title "$text" -- "$@"
    else
        [[ "$QUIET_MODE" != "true" ]] && echo -e "${CYAN}→${NC} $text" >&2
        "$@"
    fi
}

confirm() {
    local prompt="$1"
    local default="${2:-false}"

    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        gum confirm "$prompt"
    else
        if ! can_prompt; then
            [[ "$default" == "true" ]]
            return $?
        fi

        local yn
        if [[ "$default" == "true" ]]; then
            read -rp "$prompt [Y/n] " yn
            case "${yn,,}" in
                n|no) return 1 ;;
                *) return 0 ;;
            esac
        else
            read -rp "$prompt [y/N] " yn
            case "${yn,,}" in
                y|yes) return 0 ;;
                *) return 1 ;;
            esac
        fi
    fi
}

choose() {
    local prompt="$1"
    local choice=""
    shift
    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        gum choose --header "$prompt" "$@"
    else
        echo "$prompt" >&2
        local i=1
        for opt in "$@"; do
            echo "  $i) $opt" >&2
            ((i++))
        done
        read -rp "Enter number: " choice
        local idx=1
        for opt in "$@"; do
            if [[ "$idx" == "$choice" ]]; then
                echo "$opt"
                return 0
            fi
            ((idx++))
        done
        echo "$1"  # default to first
    fi
}

input() {
    local prompt="$1"
    local default="${2:-}"
    local value=""
    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        if [[ -n "$default" ]]; then
            gum input --placeholder "$default" --prompt "$prompt: " --value "$default"
        else
            gum input --prompt "$prompt: "
        fi
    else
        if [[ -n "$default" ]]; then
            read -rp "$prompt [$default]: " value
            echo "${value:-$default}"
        else
            read -rp "$prompt: " value
            echo "$value"
        fi
    fi
}

file_picker() {
    local prompt="$1"
    local path=""
    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        # Don't use --all to hide hidden files (.git, .apr, etc.)
        gum file --file --header "$prompt"
    else
        read -rp "$prompt (enter path): " path
        echo "$path"
    fi
}

# -----------------------------------------------------------------------------
# Configuration Management
# -----------------------------------------------------------------------------

# Show first-run welcome message for users who haven't set up yet
show_first_run_welcome() {
    print_banner
    echo "" >&2
    print_header "WELCOME TO APR!"
    echo "" >&2
    echo "  APR automates iterative specification refinement using" >&2
    echo "  GPT Pro Extended Reasoning via Oracle." >&2
    echo "" >&2
    print_info "To get started, run the setup wizard:"
    echo "" >&2
    echo -e "    ${CYAN}apr setup${NC}" >&2
    echo "" >&2
    print_dim "This will configure your workflow and document paths."
    print_dim "For full documentation, run 'apr help'."
    echo "" >&2
}

ensure_config_dir() {
    mkdir -p "$CONFIG_DIR"
    mkdir -p "$CONFIG_DIR/workflows"
    mkdir -p "$CONFIG_DIR/rounds"
}

load_config() {
    local workflow="${1:-default}"
    local config_path="$CONFIG_DIR/workflows/$workflow.yaml"

    if [[ ! -f "$config_path" ]]; then
        config_path="$CONFIG_DIR/config.yaml"
    fi

    if [[ ! -f "$config_path" ]]; then
        return 1
    fi

    echo "$config_path"
}

get_config_value() {
    local key="$1"
    local config_file="$2"
    # Handle both top-level and nested YAML keys while ignoring block scalar content.
    awk -v key="$key" '
        function indent_len(line) { match(line, /^[[:space:]]*/); return RLENGTH }
        BEGIN { in_block = 0; block_indent = 0 }
        {
            if (in_block) {
                if ($0 ~ /^[[:space:]]*$/) {
                    next
                }
                if (indent_len($0) <= block_indent) {
                    in_block = 0
                } else {
                    next
                }
            }
            if ($0 ~ /^[[:space:]]*[^#][^:]*:[[:space:]]*[|>][-+]?[[:space:]]*$/) {
                block_indent = indent_len($0)
                in_block = 1
                next
            }
            if ($0 ~ "^[[:space:]]*" key ":[[:space:]]*") {
                line = $0
                sub("^[[:space:]]*" key ":[[:space:]]*", "", line)
                sub(/[[:space:]]*$/, "", line)
                print line
                exit
            }
        }
    ' "$config_file"
}

# Quote a scalar value for YAML (double-quoted).
yaml_quote() {
    local value="$1"
    value=${value//\\/\\\\}
    value=${value//\"/\\\"}
    printf '"%s"' "$value"
}

# Extract a YAML block scalar (| or >) for a given key.
# Returns block contents via stdout, or empty if not found.
get_yaml_block() {
    local key="$1"
    local config_file="$2"

    awk -v key="$key" '
        BEGIN {
            found = 0
            indent_len = 0
            indent = ""
        }
        {
            if (!found) {
                if ($0 ~ "^[[:space:]]*" key ":[[:space:]]*[|>][-+]?[[:space:]]*$") {
                    found = 1
                    next
                }
            } else {
                if ($0 ~ /^[[:space:]]*$/) {
                    print ""
                    next
                }
                if (indent_len == 0) {
                    if ($0 ~ /^[[:space:]]*$/) {
                        print ""
                        next
                    }
                    match($0, /^[[:space:]]+/)
                    if (RLENGTH == 0) {
                        exit
                    }
                    indent_len = RLENGTH
                    indent = substr($0, 1, indent_len)
                }
                match($0, /^[[:space:]]+/)
                if (RLENGTH < indent_len) {
                    exit
                }
                line = $0
                sub("^" indent, "", line)
                print line
            }
        }
    ' "$config_file"
}

load_prompt_template() {
    local include_impl="$1"
    local config_file="$2"
    local template=""

    if [[ -z "$config_file" || ! -f "$config_file" ]]; then
        return 0
    fi

    if [[ "$include_impl" == "true" ]]; then
        template=$(get_yaml_block "template_with_impl" "$config_file")
    fi

    if [[ -z "$template" ]]; then
        template=$(get_yaml_block "template" "$config_file")
    fi

    printf '%s' "$template"
}

# Build the revision prompt for GPT Pro review
# Usage: build_revision_prompt [include_impl]
# Returns prompt via stdout
build_revision_prompt() {
    local include_impl="${1:-false}"
    local config_file="${2:-}"
    local template=""

    template=$(load_prompt_template "$include_impl" "$config_file")
    if [[ -n "$template" ]]; then
        printf '%s\n' "$template"
        return 0
    fi

    local prompt="First, read this README:

\`\`\`
<contents of README will be included by oracle>
\`\`\`

---
"

    if [[ "$include_impl" == "true" ]]; then
        prompt+="
And here is a document detailing the implementation; you should also keep
the implementation in mind as you think about the specification, since
ultimately the specification needs to be translated into code eventually!

\`\`\`
<contents of implementation will be included by oracle>
\`\`\`

---
"
    fi

    prompt+="
NOW: Carefully review this entire plan for me and come up with your best
revisions in terms of better architecture, new features, changed features,
etc. to make it better, more robust/reliable, more performant, more
compelling/useful, etc.

For each proposed change, give me your detailed analysis and
rationale/justification for why it would make the project better along
with the git-diff style change versus the original plan shown below:

\`\`\`
<contents of spec will be included by oracle>
\`\`\`
"

    printf '%s\n' "$prompt"
}

# -----------------------------------------------------------------------------
# Interactive Setup Wizard
# -----------------------------------------------------------------------------

run_setup() {
    print_banner

    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        gum style \
            --border rounded \
            --border-foreground 39 \
            --padding "1 2" \
            --margin "0 0 1 0" \
            "Welcome to the APR Setup Wizard!" \
            "" \
            "This will help you configure a new revision workflow." \
            "You'll specify your documents and review preferences." >&2
    else
        echo "" >&2
        echo -e "${BOLD}Welcome to the APR Setup Wizard!${NC}" >&2
        echo "" >&2
        echo "  This will help you configure a new revision workflow." >&2
        echo "  You'll specify your documents and review preferences." >&2
    fi
    echo "" >&2

    ensure_config_dir

    # Step 1: Workflow name
    print_step 1 5 "Workflow name"
    local workflow_name
    while true; do
        workflow_name=$(input "Workflow name" "default")
        # Validate: alphanumeric, hyphens, underscores only
        if [[ ! "$workflow_name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
            print_error "Invalid name: use only letters, numbers, hyphens, underscores"
            continue
        fi
        # Check for existing workflow
        if [[ -f "$CONFIG_DIR/workflows/$workflow_name.yaml" ]]; then
            print_warning "Workflow '$workflow_name' already exists"
            if ! confirm "Overwrite existing workflow?"; then
                continue
            fi
        fi
        break
    done
    echo "" >&2

    # Step 2: Project description
    print_step 2 5 "Project description"
    local description
    description=$(input "Brief description" "Iterative specification refinement")
    echo "" >&2

    # Step 3: README/Overview document
    print_step 3 5 "README/Overview document"
    print_info "Select the main README or overview document"
    local readme_path
    readme_path=$(file_picker "Select README file")
    if [[ ! -f "$readme_path" ]]; then
        print_error "File not found: $readme_path"
        exit $EXIT_CONFIG_ERROR
    fi
    print_success "README: $readme_path"
    echo "" >&2

    # Step 4: Specification document
    print_step 4 5 "Specification document"
    print_info "Select the main specification/plan document"
    local spec_path
    spec_path=$(file_picker "Select specification file")
    if [[ ! -f "$spec_path" ]]; then
        print_error "File not found: $spec_path"
        exit $EXIT_CONFIG_ERROR
    fi
    print_success "Specification: $spec_path"
    echo "" >&2

    # Step 5: Implementation document (optional)
    print_step 0 0 "Implementation document" "optional"
    local impl_path=""
    if confirm "Do you have an implementation/reference document?"; then
        impl_path=$(file_picker "Select implementation file")
        if [[ -n "$impl_path" && ! -f "$impl_path" ]]; then
            print_warning "File not found: $impl_path (skipping)"
            impl_path=""
        else
            print_success "Implementation: $impl_path"
        fi
    fi
    echo "" >&2

    # Step 5: Review preferences
    print_step 5 5 "Review preferences"
    local model
    model=$(choose "Select GPT model for reviews:" \
        "5.2 Thinking (Extended Reasoning)" \
        "gpt-5.2-pro" \
        "gpt-5.2")

    # Extract model name
    case "$model" in
        "5.2 Thinking"*) model="5.2 Thinking" ;;
        *) ;;
    esac

    echo "" >&2

    # Create workflow directory and config
    local workflow_dir="$CONFIG_DIR/workflows"
    mkdir -p "$workflow_dir"
    mkdir -p "$CONFIG_DIR/rounds/$workflow_name"

    # Write config file
    cat > "$workflow_dir/$workflow_name.yaml" << EOF
# APR Workflow Configuration
# Generated: $(date -u +"%Y-%m-%dT%H:%M:%SZ")

name: $workflow_name
description: $(yaml_quote "$description")

documents:
  readme: $(yaml_quote "$readme_path")
  spec: $(yaml_quote "$spec_path")
  implementation: $(yaml_quote "${impl_path:-}")

oracle:
  model: "$model"
  thinking_time: heavy

rounds:
  output_dir: $(yaml_quote "$CONFIG_DIR/rounds/$workflow_name")
EOF

    # Create default config if this is the first workflow
    if [[ ! -f "$CONFIG_DIR/config.yaml" ]]; then
        cat > "$CONFIG_DIR/config.yaml" << EOF
# APR Global Configuration
default_workflow: $workflow_name
EOF
    fi

    echo "" >&2
    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        gum style \
            --border rounded \
            --border-foreground 82 \
            --padding "1 2" \
            "✓ Workflow '$workflow_name' created successfully!" \
            "" \
            "To run your first revision round:" \
            "  apr run 1" \
            "" \
            "To run with implementation doc:" \
            "  apr run 1 --include-impl" >&2
    else
        echo "" >&2
        print_success "Workflow '$workflow_name' created successfully!"
        echo "" >&2
        echo "  To run your first revision round:" >&2
        echo -e "    ${CYAN}apr run 1${NC}" >&2
        echo "" >&2
        echo "  To run with implementation doc:" >&2
        echo -e "    ${CYAN}apr run 1 --include-impl${NC}" >&2
    fi
}

# -----------------------------------------------------------------------------
# Run Revision Round
# -----------------------------------------------------------------------------

run_round() {
    local round_num="$1"
    local workflow="${WORKFLOW:-default}"
    local include_impl="${INCLUDE_IMPL:-false}"
    local dry_run="${DRY_RUN:-false}"
    local render="${RENDER:-false}"
    local copy="${COPY:-false}"
    local wait_mode="${WAIT_MODE:-false}"
    local manual_login="${MANUAL_LOGIN:-false}"
    local keep_browser="${KEEP_BROWSER:-false}"
    local skip_preflight="${SKIP_PREFLIGHT:-false}"
    local enable_retry="${ENABLE_RETRY:-true}"

    print_banner

    verbose "Starting run_round: round=$round_num workflow=$workflow"
    verbose "Options: include_impl=$include_impl dry_run=$dry_run render=$render"
    verbose "Options: wait_mode=$wait_mode manual_login=$manual_login"
    verbose "Options: skip_preflight=$skip_preflight enable_retry=$enable_retry"

    # Load workflow config
    local config_path="$CONFIG_DIR/workflows/$workflow.yaml"
    verbose "Loading workflow config: $config_path"
    if [[ ! -f "$config_path" ]]; then
        # If no config at all, show the friendly welcome experience
        if [[ ! -d "$CONFIG_DIR" || ! -f "$CONFIG_DIR/config.yaml" ]]; then
            show_first_run_welcome
        else
            print_error "Workflow '$workflow' not found"
            print_info "Run 'apr setup' to create a new workflow"
            print_info "Or 'apr list' to see available workflows"
        fi
        exit $EXIT_CONFIG_ERROR
    fi

    # Parse config (simple grep-based for now)
    local readme_path spec_path impl_path model output_dir
    readme_path=$(get_config_value "readme" "$config_path" | tr -d '"')
    spec_path=$(get_config_value "spec" "$config_path" | tr -d '"')
    impl_path=$(get_config_value "implementation" "$config_path" | tr -d '"')
    model=$(get_config_value "model" "$config_path" | tr -d '"')
    output_dir=$(get_config_value "output_dir" "$config_path" | tr -d '"')

    local config_errors=()
    [[ -z "$model" ]] && config_errors+=("Model not configured in workflow")
    [[ -z "$output_dir" ]] && config_errors+=("Output directory not configured in workflow")
    if [[ ${#config_errors[@]} -gt 0 ]]; then
        local errors_json
        errors_json=$(printf '%s\n' "${config_errors[@]}" | jq -Rsc 'split("\n") | map(select(length > 0))')
        robot_json false "validation_failed" "$(jq -nc --argjson errors "$errors_json" '{errors: $errors}')" \
            "Fix workflow configuration before running"
        return 1
    fi

    verbose "Config parsed:"
    verbose "  README: $readme_path"
    verbose "  Spec: $spec_path"
    verbose "  Implementation: ${impl_path:-<not configured>}"
    verbose "  Model: $model"
    verbose "  Output dir: $output_dir"

    if [[ -z "$model" ]]; then
        print_error "Model not configured in $config_path"
        exit $EXIT_CONFIG_ERROR
    fi
    if [[ -z "$output_dir" ]]; then
        print_error "Output directory not configured in $config_path"
        exit $EXIT_CONFIG_ERROR
    fi

    # Run pre-flight checks (unless skipped or dry-run/render mode)
    if [[ "$skip_preflight" != "true" && "$dry_run" != "true" && "$render" != "true" ]]; then
        local impl_for_preflight=""
        [[ "$include_impl" == "true" && -n "$impl_path" ]] && impl_for_preflight="$impl_path"

        local preflight_result=0
        preflight_check "$readme_path" "$spec_path" "$impl_for_preflight" || preflight_result=$?

        if [[ $preflight_result -eq 1 ]]; then
            print_error "Pre-flight checks failed. Fix the issues above and try again."
            print_info "Use --no-preflight to skip these checks (not recommended)"
            exit $EXIT_CONFIG_ERROR
        fi
        # preflight_result=2 means warnings only, continue execution
    else
        verbose "Skipping pre-flight checks (skip_preflight=$skip_preflight dry_run=$dry_run render=$render)"
        # Basic file validation when preflight is skipped
        for f in "$readme_path" "$spec_path"; do
            if [[ ! -f "$f" ]]; then
                print_error "Required file not found: $f"
                exit $EXIT_CONFIG_ERROR
            fi
        done
    fi

    if [[ "$include_impl" == "true" ]]; then
        if [[ -z "$impl_path" ]]; then
            print_warning "Implementation document not configured; skipping"
            include_impl=false
        elif [[ ! -f "$impl_path" ]]; then
            print_warning "Implementation file not found: $impl_path"
            include_impl=false
        fi
    fi

    # Display round info
    local slug="apr-${workflow}-round-${round_num}"
    local output_file="${output_dir}/round_${round_num}.md"

    if [[ "$include_impl" == "true" && -n "$impl_path" ]]; then
        slug="${slug}-with-impl"
    fi

    # Warn if output file already exists
    if [[ -f "$output_file" && "$dry_run" != "true" && "$render" != "true" ]]; then
        local file_size
        file_size=$(du -h "$output_file" 2>/dev/null | cut -f1)
        print_warning "Round $round_num output already exists ($file_size)"
        if can_prompt; then
            if ! confirm "Overwrite existing output?"; then
                print_info "Cancelled. Use a different round number or backup the file."
                exit $EXIT_SUCCESS
            fi
        fi
    fi

    if [[ "$GUM_AVAILABLE" == "true" && "$QUIET_MODE" != "true" ]]; then
        gum style \
            --border rounded \
            --border-foreground 212 \
            --padding "1 2" \
            --margin "0 0 1 0" \
            "$(gum style --foreground 212 --bold "REVISION ROUND $round_num")" \
            "" \
            "$(gum style --foreground 39 "Workflow:") $workflow" \
            "$(gum style --foreground 39 "Model:") $model" \
            "$(gum style --foreground 39 "Include impl:") $include_impl" \
            "$(gum style --foreground 39 "Output:") $output_file" >&2
    elif [[ "$QUIET_MODE" != "true" ]]; then
        echo "" >&2
        echo -e "  ${BOLD}${MAGENTA}REVISION ROUND $round_num${NC}" >&2
        echo "" >&2
        echo -e "  ${CYAN}Workflow:${NC}     $workflow" >&2
        echo -e "  ${CYAN}Model:${NC}        $model" >&2
        echo -e "  ${CYAN}Include impl:${NC} $include_impl" >&2
        echo -e "  ${CYAN}Output:${NC}       $output_file" >&2
    fi
    echo "" >&2

    # Build file arguments
    local file_args=(--file "$readme_path")
    if [[ "$include_impl" == "true" && -n "$impl_path" ]]; then
        file_args+=(--file "$impl_path")
    fi
    file_args+=(--file "$spec_path")

    # Build prompt using shared function
    local prompt
    prompt=$(build_revision_prompt "$include_impl" "$config_path")
    if [[ -z "$prompt" ]]; then
        if [[ "$ROBOT_MODE" == "true" ]]; then
            robot_json false "validation_failed" '{"errors":["Prompt template is empty"]}' \
                "Add 'template' or 'template_with_impl' to workflow"
        else
            print_error "Prompt template is empty"
            print_info "Add 'template' or 'template_with_impl' to $config_path"
        fi
        return 1
    fi

    # Dry run mode
    if [[ "$dry_run" == "true" ]]; then
        print_header "DRY RUN"
        echo "" >&2
        print_info "Would execute:"
        echo "" >&2
        echo "  $ORACLE_CMD --engine browser \\" >&2
        echo "    -m \"$model\" \\" >&2
        for f in "${file_args[@]}"; do
            echo "    $f \\" >&2
        done
        echo "    --slug \"$slug\" \\" >&2
        echo "    --write-output \"$output_file\" \\" >&2
        [[ "$manual_login" == "true" ]] && echo "    --browser-manual-login \\" >&2
        [[ "$keep_browser" == "true" ]] && echo "    --browser-keep-browser \\" >&2
        echo "    --notify --heartbeat 30 \\" >&2
        echo "    -p \"<prompt>\"" >&2
        exit $EXIT_SUCCESS
    fi

    # Render mode
    if [[ "$render" == "true" ]]; then
        local render_args=("--render")
        [[ "$copy" == "true" ]] && render_args+=("--copy")

        print_info "Rendering bundle for manual use..."
        $ORACLE_CMD "${file_args[@]}" "${render_args[@]}" -p "$prompt"
        exit $EXIT_SUCCESS
    fi

    # Acquire lock to prevent concurrent runs of the same workflow/round (foreground only)
    # In background mode, we rely on the output file overwrite warning
    if [[ "$wait_mode" == "true" ]]; then
        if ! acquire_lock "$workflow" "$round_num"; then
            print_error "Another APR process is already running round $round_num for workflow '$workflow'"
            print_info "Wait for it to complete or check 'apr status'"
            exit $EXIT_CONFIG_ERROR
        fi
    fi

    # Build Oracle command
    local oracle_args=(
        --engine browser
        -m "$model"
        "${file_args[@]}"
        --slug "$slug"
        --write-output "$output_file"
        --files-report
        --notify
        --heartbeat 30
    )

    [[ "$manual_login" == "true" ]] && oracle_args+=(--browser-manual-login)
    [[ "$keep_browser" == "true" ]] && oracle_args+=(--browser-keep-browser)
    oracle_args+=(-p "$prompt")

    verbose "Oracle command: $ORACLE_CMD ${oracle_args[*]}"
    verbose "Output file: $output_file"
    verbose "Session slug: $slug"

    # Create output directory
    mkdir -p "$(dirname "$output_file")"

    # Execute
    print_info "Starting GPT Pro Extended Reasoning review..."
    print_dim "This may take 10-60 minutes depending on complexity."
    echo "" >&2

    if [[ "$manual_login" == "true" ]]; then
        print_warning "Manual login mode enabled"
        print_dim "Chrome will open - log into ChatGPT if prompted"
        print_dim "Your session will be saved for future runs"
        echo "" >&2
    fi

    if [[ "$wait_mode" == "true" ]]; then
        print_info "Running in foreground (--wait)..."
        [[ "$enable_retry" == "true" ]] && print_dim "Auto-retry enabled (up to $MAX_RETRY_ATTEMPTS attempts)"
        print_dim "Elapsed time will be shown on completion."
        echo "" >&2
        local start_time oracle_exit=0
        start_time=$(date +%s)

        # Use auto-retry wrapper if enabled
        if [[ "$enable_retry" == "true" ]]; then
            run_oracle_with_retry "${oracle_args[@]}" || oracle_exit=$?
        else
            $ORACLE_CMD "${oracle_args[@]}" || oracle_exit=$?
        fi

        local end_time elapsed_secs elapsed_fmt
        end_time=$(date +%s)
        elapsed_secs=$((end_time - start_time))
        # Format elapsed time as HH:MM:SS or MM:SS
        if (( elapsed_secs >= 3600 )); then
            elapsed_fmt=$(printf '%d:%02d:%02d' $((elapsed_secs/3600)) $((elapsed_secs%3600/60)) $((elapsed_secs%60)))
        else
            elapsed_fmt=$(printf '%d:%02d' $((elapsed_secs/60)) $((elapsed_secs%60)))
        fi
        echo "" >&2

        if [[ $oracle_exit -eq 0 ]]; then
            print_success "Review complete! (${elapsed_fmt} elapsed)"
            print_info "Output saved to: $output_file"
        else
            print_error "Oracle failed after ${elapsed_fmt} (exit code: $oracle_exit)"
            exit $oracle_exit
        fi
    else
        $ORACLE_CMD "${oracle_args[@]}" &
        local oracle_pid=$!

        # Brief delay to verify process started
        sleep 0.5

        # Verify the process is actually running
        if ! kill -0 "$oracle_pid" 2>/dev/null; then
            print_error "Oracle process failed to start"
            print_info "Try running with --wait to see error output"
            exit $EXIT_DEPENDENCY_ERROR
        fi

        print_success "Oracle running in background (PID: $oracle_pid)"
        echo "" >&2

        if [[ "$GUM_AVAILABLE" == "true" && "$QUIET_MODE" != "true" ]]; then
            gum style \
                --border rounded \
                --border-foreground 39 \
                --padding "1 2" \
                "$(gum style --foreground 214 --bold "MONITORING COMMANDS")" \
                "" \
                "Check status:      $(gum style --foreground 82 "apr status")" \
                "Attach to session: $(gum style --foreground 82 "apr attach $slug")" \
                "View with output:  $(gum style --foreground 82 "$ORACLE_CMD session $slug --render")" >&2
        elif [[ "$QUIET_MODE" != "true" ]]; then
            echo -e "  ${BOLD}${CYAN}MONITORING COMMANDS${NC}" >&2
            echo "" >&2
            echo -e "  Check status:      ${GREEN}apr status${NC}" >&2
            echo -e "  Attach to session: ${GREEN}apr attach $slug${NC}" >&2
            echo -e "  View with output:  ${GREEN}$ORACLE_CMD session $slug --render${NC}" >&2
        fi

        echo "" >&2
        print_info "Output will be saved to: $output_file"
    fi

    echo "" >&2
    print_header "NEXT STEPS AFTER REVIEW COMPLETES"

    # Contextual tips based on round number and options
    local tips=()
    tips+=("Review the output in $output_file")
    tips+=("Integrate feedback into your specification")
    tips+=("Update README to reflect changes")

    if [[ -n "$impl_path" ]]; then
        tips+=("Harmonize implementation doc")
    fi

    tips+=("Commit changes and repeat")

    # Show numbered steps
    local step=1
    for tip in "${tips[@]}"; do
        echo "$step. $tip" >&2
        ((step++))
    done

    echo "" >&2

    # Contextual suggestions
    if [[ "$round_num" == "1" && "$manual_login" != "true" ]]; then
        print_dim "Tip: For first runs, use --login to handle browser authentication"
    elif [[ "$round_num" -ge 3 && "$include_impl" != "true" && -n "$impl_path" ]]; then
        print_dim "Tip: Try using --include-impl to get implementation-aware feedback"
    elif [[ "$round_num" -ge 5 ]]; then
        print_dim "Tip: After 5+ rounds, look for convergence - similar feedback suggests stability"
    fi
}

# -----------------------------------------------------------------------------
# Status & Session Management
# -----------------------------------------------------------------------------

show_status() {
    print_banner
    print_header "ORACLE SESSION STATUS"
    print_info "Showing sessions from last ${STATUS_HOURS}h"
    echo "" >&2
    $ORACLE_CMD status --hours "$STATUS_HOURS"
}

attach_session() {
    local session="$1"
    print_banner
    print_info "Attaching to session: $session"
    echo "" >&2
    $ORACLE_CMD session "$session" --render
}

# -----------------------------------------------------------------------------
# List Workflows
# -----------------------------------------------------------------------------

list_workflows() {
    print_banner
    print_header "CONFIGURED WORKFLOWS"
    echo "" >&2

    local workflow_dir="$CONFIG_DIR/workflows"
    if [[ ! -d "$workflow_dir" ]]; then
        print_warning "No workflows configured yet"
        print_info "Run 'apr setup' to create your first workflow"
        exit $EXIT_SUCCESS
    fi

    # Get default workflow
    local default_wf=""
    if [[ -f "$CONFIG_DIR/config.yaml" ]]; then
        default_wf=$(get_config_value "default_workflow" "$CONFIG_DIR/config.yaml")
    fi

    local found_any=false
    for config in "$workflow_dir"/*.yaml; do
        [[ -f "$config" ]] || continue
        found_any=true
        local name desc is_default=""
        name=$(basename "$config" .yaml)
        desc=$(get_config_value "description" "$config")

        if [[ "$name" == "$default_wf" ]]; then
            is_default=" (default)"
        fi

        if [[ "$GUM_AVAILABLE" == "true" ]]; then
            if [[ -n "$is_default" ]]; then
                gum style --foreground 82 --bold "$name" --suffix " $(gum style --faint '(default)')" >&2
            else
                gum style --foreground 82 --bold "$name" >&2
            fi
            gum style --faint "  $desc" >&2
        else
            echo -e "  ${GREEN}${BOLD}$name${NC}${DIM}$is_default${NC}" >&2
            echo -e "    ${DIM}$desc${NC}" >&2
        fi
        echo "" >&2
    done

    if [[ "$found_any" == "false" ]]; then
        print_warning "No workflows configured yet"
        print_info "Run 'apr setup' to create your first workflow"
    fi
}

# -----------------------------------------------------------------------------
# History
# -----------------------------------------------------------------------------

show_history() {
    local workflow="${WORKFLOW:-default}"

    # Verify workflow exists
    local workflow_file="$CONFIG_DIR/workflows/${workflow}.yaml"
    if [[ ! -f "$workflow_file" ]]; then
        print_error "Workflow '$workflow' not found"
        print_info "Run 'apr list' to see available workflows"
        exit $EXIT_CONFIG_ERROR
    fi

    print_banner
    print_header "REVISION HISTORY: $workflow"
    echo "" >&2

    local rounds_dir="$CONFIG_DIR/rounds/$workflow"
    if [[ ! -d "$rounds_dir" ]]; then
        print_warning "No rounds recorded yet for workflow '$workflow'"
        print_info "Run 'apr run 1' to start your first revision round"
        exit $EXIT_SUCCESS
    fi

    # Collect all round files and find the latest
    local round_entries=()
    local latest_round=0
    for round_file in "$rounds_dir"/round_*.md; do
        [[ -f "$round_file" ]] || continue
        local num
        num=$(basename "$round_file" .md | sed 's/round_//')
        if [[ "$num" =~ ^[0-9]+$ ]]; then
            round_entries+=("${num}|${round_file}")
            if (( num > latest_round )); then
                latest_round=$num
            fi
        fi
    done

    if [[ ${#round_entries[@]} -eq 0 ]]; then
        print_warning "No rounds recorded yet for workflow '$workflow'"
        print_info "Run 'apr run 1' to start your first revision round"
        exit $EXIT_SUCCESS
    fi

    local sorted_entries=()
    mapfile -t sorted_entries < <(printf '%s\n' "${round_entries[@]}" | sort -n -t '|' -k1,1)

    # Display each round with enhanced info
    for entry in "${sorted_entries[@]}"; do
        local round_num round_file size mod_date mod_ts first_line is_latest=""
        round_num=${entry%%|*}
        round_file=${entry#*|}
        size=$(du -h "$round_file" 2>/dev/null | cut -f1)
        # Cross-platform date: try GNU stat, then BSD stat, then date fallback
        mod_ts=$(stat -c '%Y' "$round_file" 2>/dev/null || stat -f '%m' "$round_file" 2>/dev/null || echo "")
        if [[ -n "$mod_ts" && "$mod_ts" =~ ^[0-9]+$ ]]; then
            mod_date=$(date -d "@$mod_ts" '+%Y-%m-%d %H:%M' 2>/dev/null || date -r "$mod_ts" '+%Y-%m-%d %H:%M' 2>/dev/null || echo "N/A")
        else
            mod_date="N/A"
        fi

        # Get first non-empty line as preview
        first_line=$(grep -m1 '.' "$round_file" 2>/dev/null | head -c 60 | tr '\n' ' ')
        [[ ${#first_line} -eq 60 ]] && first_line="${first_line}..."

        # Mark latest round
        if [[ "$round_num" == "$latest_round" ]]; then
            is_latest=" ${GREEN}(latest)${NC}"
        fi

        if [[ "$GUM_AVAILABLE" == "true" ]]; then
            echo "$(gum style --foreground 82 --bold "Round $round_num")${is_latest}  $(gum style --faint "$size  $mod_date")" >&2
            [[ -n "$first_line" ]] && gum style --faint "    $first_line" >&2
        else
            echo -e "  ${CYAN}${BOLD}Round $round_num${NC}${is_latest}  ${DIM}$size  $mod_date${NC}" >&2
            [[ -n "$first_line" ]] && echo -e "    ${DIM}$first_line${NC}" >&2
        fi
        echo "" >&2
    done

    # Summary
    print_dim "Total: ${#round_entries[@]} round(s). Use 'apr show <round>' to view content."
}

# -----------------------------------------------------------------------------
# Show Round Output
# -----------------------------------------------------------------------------

show_round() {
    local round_num="$1"
    local workflow="${WORKFLOW:-default}"

    # Verify workflow exists
    local workflow_file="$CONFIG_DIR/workflows/${workflow}.yaml"
    if [[ ! -f "$workflow_file" ]]; then
        print_error "Workflow '$workflow' not found"
        print_info "Run 'apr list' to see available workflows"
        exit $EXIT_CONFIG_ERROR
    fi

    local output_file="$CONFIG_DIR/rounds/$workflow/round_${round_num}.md"

    if [[ ! -f "$output_file" ]]; then
        print_error "Round $round_num not found for workflow '$workflow'"
        print_info "Run 'apr history' to see available rounds"
        exit $EXIT_CONFIG_ERROR
    fi

    # If pager is available and stdout is a tty, use it
    if [[ -t 1 ]]; then
        if command -v bat &>/dev/null; then
            bat --style=plain --language=markdown "$output_file"
        elif command -v less &>/dev/null; then
            less "$output_file"
        else
            cat "$output_file"
        fi
    else
        cat "$output_file"
    fi
}

# -----------------------------------------------------------------------------
# Diff Rounds - Compare two round outputs
# -----------------------------------------------------------------------------

diff_rounds() {
    local round_a="$1"
    local round_b="${2:-}"
    local workflow="${WORKFLOW:-default}"

    verbose "diff_rounds: round_a=$round_a round_b=${round_b:-<auto>} workflow=$workflow"

    # Verify workflow exists
    local workflow_file="$CONFIG_DIR/workflows/${workflow}.yaml"
    if [[ ! -f "$workflow_file" ]]; then
        print_error "Workflow '$workflow' not found"
        print_info "Run 'apr list' to see available workflows"
        exit $EXIT_CONFIG_ERROR
    fi

    local rounds_dir="$CONFIG_DIR/rounds/$workflow"

    # If only one round given, compare with previous
    if [[ -z "$round_b" ]]; then
        if [[ "$round_a" -le 1 ]]; then
            print_error "Round 1 has no previous round to compare with"
            print_info "Usage: apr diff <round_a> <round_b>"
            exit $EXIT_USAGE_ERROR
        fi
        round_b=$((round_a - 1))
        verbose "Auto-selected round_b=$round_b (previous round)"
    fi

    local file_a="$rounds_dir/round_${round_a}.md"
    local file_b="$rounds_dir/round_${round_b}.md"

    # Validate both files exist
    if [[ ! -f "$file_a" ]]; then
        print_error "Round $round_a not found for workflow '$workflow'"
        print_info "Run 'apr history' to see available rounds"
        exit $EXIT_CONFIG_ERROR
    fi
    if [[ ! -f "$file_b" ]]; then
        print_error "Round $round_b not found for workflow '$workflow'"
        print_info "Run 'apr history' to see available rounds"
        exit $EXIT_CONFIG_ERROR
    fi

    local size_a size_b
    size_a=$(du -h "$file_a" 2>/dev/null | cut -f1)
    size_b=$(du -h "$file_b" 2>/dev/null | cut -f1)

    print_banner
    print_header "ROUND COMPARISON: $round_b → $round_a"
    echo "" >&2
    print_info "Comparing Round $round_b ($size_b) with Round $round_a ($size_a)"
    echo "" >&2

    # Use delta if available (beautiful diff), otherwise fall back to diff
    # Note: diff returns 1 when files differ (expected), so we use || true to prevent
    # script exit with set -euo pipefail. Exit code 2 indicates an actual error.
    if command -v delta &>/dev/null; then
        verbose "Using delta for diff"
        delta --side-by-side "$file_b" "$file_a" || true
    elif command -v diff &>/dev/null; then
        verbose "Using diff (delta not available)"
        # Use colored diff if terminal supports it
        if [[ -t 1 ]] && diff --color=auto /dev/null /dev/null 2>/dev/null; then
            if command -v less &>/dev/null; then
                diff --color=auto -u "$file_b" "$file_a" | less -R || true
            else
                diff --color=auto -u "$file_b" "$file_a" || true
            fi
        else
            if [[ -t 1 ]] && command -v less &>/dev/null; then
                diff -u "$file_b" "$file_a" | less || true
            else
                diff -u "$file_b" "$file_a" || true
            fi
        fi
    else
        print_error "No diff tool available (install delta for best experience)"
        exit $EXIT_DEPENDENCY_ERROR
    fi
}

# -----------------------------------------------------------------------------
# Integrate - Generate Claude Code integration prompt
# -----------------------------------------------------------------------------

generate_integration() {
    local round_num="$1"
    local workflow="${WORKFLOW:-default}"
    local output_path="${INTEGRATE_OUTPUT:-}"
    local copy_to_clipboard="${COPY:-false}"

    verbose "generate_integration: round=$round_num workflow=$workflow output=${output_path:-<stdout>} copy=$copy_to_clipboard"

    # Verify workflow exists
    local workflow_file="$CONFIG_DIR/workflows/${workflow}.yaml"
    if [[ ! -f "$workflow_file" ]]; then
        print_error "Workflow '$workflow' not found"
        print_info "Run 'apr list' to see available workflows"
        exit $EXIT_CONFIG_ERROR
    fi

    # Get workflow config
    local spec_path
    spec_path=$(get_config_value "spec" "$workflow_file" | tr -d '"')
    if [[ -z "$spec_path" ]]; then
        print_error "Spec path not configured in workflow '$workflow'"
        print_info "Check 'spec:' in $workflow_file"
        exit $EXIT_CONFIG_ERROR
    fi
    if [[ ! -f "$spec_path" ]]; then
        print_error "Spec file not found: $spec_path"
        print_info "Check 'spec:' in $workflow_file"
        exit $EXIT_CONFIG_ERROR
    fi

    local round_file="$CONFIG_DIR/rounds/$workflow/round_${round_num}.md"
    if [[ ! -f "$round_file" ]]; then
        print_error "Round $round_num not found for workflow '$workflow'"
        print_info "Run 'apr history' to see available rounds"
        exit $EXIT_CONFIG_ERROR
    fi

    local round_size
    round_size=$(du -h "$round_file" 2>/dev/null | cut -f1)

    # Build the integration prompt
    local prompt
    prompt=$(cat <<EOF
First read ALL of the AGENTS.md file and README.md file super carefully
and understand ALL of both! Then use your code investigation agent mode
to fully understand the code and technical architecture of the project.
Read ALL of the specification document at: $spec_path

Now integrate the following feedback from GPT Pro 5.2 Extended Reasoning
(Round $round_num of the APR iterative refinement process). For each
suggestion, carefully evaluate whether you agree with the proposed change.
Then apply the changes you endorse to the specification document.

Be meticulous and use ultrathink.

---

$(cat "$round_file")
EOF
)

    # Output handling
    if [[ -n "$output_path" ]]; then
        # Write to file
        echo "$prompt" > "$output_path"
        print_success "Integration prompt saved to: $output_path"
    elif [[ "$copy_to_clipboard" == "true" ]]; then
        # Copy to clipboard
        if command -v pbcopy &>/dev/null; then
            echo "$prompt" | pbcopy
            print_success "Integration prompt copied to clipboard (pbcopy)"
        elif command -v xclip &>/dev/null; then
            echo "$prompt" | xclip -selection clipboard
            print_success "Integration prompt copied to clipboard (xclip)"
        elif command -v xsel &>/dev/null; then
            echo "$prompt" | xsel --clipboard
            print_success "Integration prompt copied to clipboard (xsel)"
        else
            print_warning "No clipboard tool found (pbcopy, xclip, xsel)"
            print_info "Outputting to stdout instead:"
            echo ""
            echo "$prompt"
        fi
    else
        # Output to stdout
        if [[ "$QUIET_MODE" != "true" ]]; then
            print_banner
            print_header "CLAUDE CODE INTEGRATION PROMPT"
            print_info "Round $round_num ($round_size) for workflow '$workflow'"
            echo "" >&2
            print_dim "Copy the following prompt to Claude Code:"
            echo "" >&2
            echo "─────────────────────────────────────────────────────────────" >&2
        fi
        echo "$prompt"
        if [[ "$QUIET_MODE" != "true" ]]; then
            echo "" >&2
            echo "─────────────────────────────────────────────────────────────" >&2
            echo "" >&2
            print_dim "Tip: Use 'apr integrate $round_num --copy' to copy to clipboard"
        fi
    fi
}

# -----------------------------------------------------------------------------
# Stats - Round analytics and convergence signals
# -----------------------------------------------------------------------------

show_stats() {
    local workflow="${WORKFLOW:-default}"

    verbose "show_stats: workflow=$workflow"

    # Verify workflow exists
    local workflow_file="$CONFIG_DIR/workflows/${workflow}.yaml"
    if [[ ! -f "$workflow_file" ]]; then
        print_error "Workflow '$workflow' not found"
        print_info "Run 'apr list' to see available workflows"
        exit $EXIT_CONFIG_ERROR
    fi

    local rounds_dir="$CONFIG_DIR/rounds/$workflow"
    if [[ ! -d "$rounds_dir" ]]; then
        print_warning "No rounds recorded yet for workflow '$workflow'"
        print_info "Run 'apr run 1' to start your first revision round"
        exit $EXIT_SUCCESS
    fi

    # Collect round data
    local total_rounds=0
    local total_size=0
    local round_data=()
    local sizes=()
    local round_entries=()

    for round_file in "$rounds_dir"/round_*.md; do
        [[ -f "$round_file" ]] || continue
        local round_num
        round_num=$(basename "$round_file" .md | sed 's/round_//')
        [[ "$round_num" =~ ^[0-9]+$ ]] || continue
        round_entries+=("${round_num}|${round_file}")
    done

    if [[ ${#round_entries[@]} -eq 0 ]]; then
        print_warning "No rounds recorded yet for workflow '$workflow'"
        print_info "Run 'apr run 1' to start your first revision round"
        exit $EXIT_SUCCESS
    fi

    local sorted_entries=()
    mapfile -t sorted_entries < <(printf '%s\n' "${round_entries[@]}" | sort -n -t '|' -k1,1)

    for entry in "${sorted_entries[@]}"; do
        local round_num round_file size_bytes size_human mod_ts
        round_num=${entry%%|*}
        round_file=${entry#*|}
        ((total_rounds++))

        size_bytes=$(stat -c '%s' "$round_file" 2>/dev/null || stat -f '%z' "$round_file" 2>/dev/null || echo "0")
        size_human=$(du -h "$round_file" 2>/dev/null | cut -f1)
        mod_ts=$(stat -c '%Y' "$round_file" 2>/dev/null || stat -f '%m' "$round_file" 2>/dev/null || echo "0")

        total_size=$((total_size + size_bytes))
        sizes+=("$size_bytes")
        round_data+=("$round_num|$size_human|$size_bytes|$mod_ts")
    done

    # Calculate statistics
    local avg_size=$((total_size / total_rounds))
    local avg_human
    if [[ $avg_size -ge 1048576 ]]; then
        avg_human="$(echo "scale=1; $avg_size / 1048576" | bc 2>/dev/null || echo "$((avg_size / 1048576))M")"
        [[ "$avg_human" != *M ]] && avg_human="${avg_human}M"
    elif [[ $avg_size -ge 1024 ]]; then
        avg_human="$(echo "scale=1; $avg_size / 1024" | bc 2>/dev/null || echo "$((avg_size / 1024))K")"
        [[ "$avg_human" != *K ]] && avg_human="${avg_human}K"
    else
        avg_human="${avg_size}B"
    fi

    # Detect trend (compare first half vs second half)
    local trend_signal=""
    if [[ $total_rounds -ge 4 ]]; then
        local half=$((total_rounds / 2))
        local first_half_avg=0 second_half_avg=0
        local i=0
        for size in "${sizes[@]}"; do
            if [[ $i -lt $half ]]; then
                first_half_avg=$((first_half_avg + size))
            else
                second_half_avg=$((second_half_avg + size))
            fi
            ((i++))
        done
        first_half_avg=$((first_half_avg / half))
        second_half_avg=$((second_half_avg / (total_rounds - half)))

        if [[ $second_half_avg -lt $((first_half_avg * 80 / 100)) ]]; then
            trend_signal="Output size trending down (convergence signal)"
        elif [[ $second_half_avg -gt $((first_half_avg * 120 / 100)) ]]; then
            trend_signal="Output size trending up (scope may be expanding)"
        else
            trend_signal="Output size stable"
        fi
    fi

    # Display stats
    print_banner
    print_header "REVISION STATISTICS: $workflow"
    echo "" >&2

    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        gum style \
            --border rounded \
            --border-foreground 212 \
            --padding "1 2" \
            "$(gum style --foreground 39 "Rounds completed:")    $total_rounds" \
            "$(gum style --foreground 39 "Average output size:") $avg_human" >&2
    else
        echo -e "  ${CYAN}Rounds completed:${NC}    $total_rounds" >&2
        echo -e "  ${CYAN}Average output size:${NC} $avg_human" >&2
    fi

    echo "" >&2
    echo -e "  ${BOLD}${YELLOW}Round    Size    Modified${NC}" >&2
    echo -e "  ${DIM}─────    ────    ────────${NC}" >&2

    # Display round table
    for data in "${round_data[@]}"; do
        IFS='|' read -r round_num size_human size_bytes mod_ts <<< "$data"
        local mod_date
        mod_date=$(date -d "@$mod_ts" '+%Y-%m-%d %H:%M' 2>/dev/null || date -r "$mod_ts" '+%Y-%m-%d %H:%M' 2>/dev/null || echo "N/A")
        printf "  %-8s %-7s %s\n" "$round_num" "$size_human" "$mod_date" >&2
    done

    echo "" >&2

    # Show trend signal if available
    if [[ -n "$trend_signal" ]]; then
        print_info "$trend_signal"
        echo "" >&2
    fi

    # Suggestions based on round count
    if [[ $total_rounds -ge 5 ]]; then
        print_dim "Tip: After 5+ rounds, look for convergence - similar feedback suggests stability"
    elif [[ $total_rounds -eq 1 ]]; then
        print_dim "Tip: Run more rounds to see convergence trends"
    fi
}

# =============================================================================
# ROBOT MODE - JSON API for coding agents
# =============================================================================
#
# All robot mode output goes to stdout as valid JSON.
# Response envelope: { ok, code, data, hint?, meta: {v, ts} }
#
# Error codes: ok, not_configured, not_found, validation_failed, oracle_error
# =============================================================================

# Robot mode state
# shellcheck disable=SC2034  # State flag for helper functions
ROBOT_MODE=false
ROBOT_COMPACT=false

# ISO8601 timestamp
iso_timestamp() {
    date -u +"%Y-%m-%dT%H:%M:%SZ"
}

# Build JSON response using jq (required for robot mode)
# Usage: robot_json ok|false code data_json [hint]
robot_json() {
    local ok="$1"
    local code="$2"
    local data="$3"
    local hint="${4:-}"
    local ts
    ts=$(iso_timestamp)

    local result
    if [[ -n "$hint" ]]; then
        result=$(jq -nc \
            --argjson ok "$ok" \
            --arg code "$code" \
            --argjson data "$data" \
            --arg hint "$hint" \
            --arg v "$VERSION" \
            --arg ts "$ts" \
            '{ok: $ok, code: $code, data: $data, hint: $hint, meta: {v: $v, ts: $ts}}')
    else
        result=$(jq -nc \
            --argjson ok "$ok" \
            --arg code "$code" \
            --argjson data "$data" \
            --arg v "$VERSION" \
            --arg ts "$ts" \
            '{ok: $ok, code: $code, data: $data, meta: {v: $v, ts: $ts}}')
    fi

    if [[ "$ROBOT_COMPACT" == "true" ]]; then
        echo "$result"
    else
        echo "$result" | jq .
    fi
}

# Robot: Status - System overview
robot_status() {
    local configured=false
    local default_workflow=""
    local workflow_count=0
    local oracle_available=false
    local oracle_method=""
    local workflows_json="[]"

    # Check configuration
    if [[ -d "$CONFIG_DIR" && -f "$CONFIG_DIR/config.yaml" ]]; then
        configured=true
        default_workflow=$(get_config_value "default_workflow" "$CONFIG_DIR/config.yaml" 2>/dev/null || echo "")
    fi

    # Count and list workflows
    if [[ -d "$CONFIG_DIR/workflows" ]]; then
        workflow_count=$(find "$CONFIG_DIR/workflows" -name "*.yaml" 2>/dev/null | wc -l | tr -d ' ')
        local wf_list=()
        for wf in "$CONFIG_DIR/workflows"/*.yaml; do
            [[ -f "$wf" ]] || continue
            wf_list+=("\"$(basename "$wf" .yaml)\"")
        done
        if [[ ${#wf_list[@]} -gt 0 ]]; then
            workflows_json="[$(IFS=,; echo "${wf_list[*]}")]"
        fi
    fi

    # Check Oracle
    if command -v oracle &>/dev/null; then
        oracle_available=true
        oracle_method="global"
    elif command -v npx &>/dev/null; then
        oracle_available=true
        oracle_method="npx"
    fi

    # Build data object with jq
    local data
    data=$(jq -nc \
        --argjson configured "$configured" \
        --arg default_workflow "$default_workflow" \
        --argjson workflow_count "$workflow_count" \
        --argjson workflows "$workflows_json" \
        --argjson oracle_available "$oracle_available" \
        --arg oracle_method "$oracle_method" \
        --arg config_dir "$CONFIG_DIR" \
        --arg apr_home "$APR_HOME" \
        '{
            configured: $configured,
            default_workflow: $default_workflow,
            workflow_count: $workflow_count,
            workflows: $workflows,
            oracle_available: $oracle_available,
            oracle_method: $oracle_method,
            config_dir: $config_dir,
            apr_home: $apr_home
        }')

    local hint=""
    if [[ "$configured" == "false" ]]; then
        hint="Run 'apr robot init' to initialize, then 'apr setup' to create workflow"
    elif [[ "$oracle_available" == "false" ]]; then
        hint="Install Oracle: npm install -g @steipete/oracle"
    fi

    robot_json true "ok" "$data" "$hint"
}

# Robot: Workflows - List all workflows
robot_workflows() {
    if [[ ! -d "$CONFIG_DIR/workflows" ]]; then
        robot_json false "not_configured" '{"workflows":[]}' "Run 'apr robot init' then 'apr setup'"
        return 1
    fi

    local items=()
    for wf in "$CONFIG_DIR/workflows"/*.yaml; do
        [[ -f "$wf" ]] || continue
        local name desc
        name=$(basename "$wf" .yaml)
        desc=$(get_config_value "description" "$wf" 2>/dev/null || echo "")
        items+=("$(jq -nc --arg name "$name" --arg desc "$desc" '{name: $name, description: $desc}')")
    done

    local workflows_json="[]"
    if [[ ${#items[@]} -gt 0 ]]; then
        workflows_json=$(printf '%s\n' "${items[@]}" | jq -sc .)
    fi

    robot_json true "ok" "{\"workflows\":$workflows_json}"
}

# Robot: Init - Initialize .apr directory
robot_init() {
    if [[ -d "$CONFIG_DIR" ]]; then
        robot_json true "ok" '{"created":false,"existed":true}' "Already initialized"
        return 0
    fi

    # Handle errors gracefully to ensure JSON output
    if ! mkdir -p "$CONFIG_DIR/workflows" "$CONFIG_DIR/rounds" 2>/dev/null; then
        robot_json false "init_failed" "$(jq -nc --arg dir "$CONFIG_DIR" '{directory: $dir}')" "Failed to create directory: $CONFIG_DIR"
        return 1
    fi

    if ! echo "default_workflow: default" > "$CONFIG_DIR/config.yaml" 2>/dev/null; then
        robot_json false "init_failed" '{"reason":"config_write"}' "Failed to write config file"
        return 1
    fi

    robot_json true "ok" '{"created":true,"existed":false}'
}

# Robot: Validate - Pre-run validation
robot_validate() {
    local round_num="${1:-}"
    local errors=()
    local warnings=()

    if [[ -z "$round_num" ]]; then
        errors+=("Round number required")
    elif ! [[ "$round_num" =~ ^[0-9]+$ ]]; then
        errors+=("Round must be a positive integer")
    fi

    if [[ ! -d "$CONFIG_DIR" ]]; then
        errors+=("Not initialized - run 'apr robot init'")
    fi

    local wf_file="$CONFIG_DIR/workflows/${WORKFLOW}.yaml"
    if [[ ! -f "$wf_file" ]]; then
        errors+=("Workflow '$WORKFLOW' not found")
    else
        # Check required documents exist
        local readme spec model output_dir
        readme=$(get_config_value "readme" "$wf_file" 2>/dev/null || echo "")
        spec=$(get_config_value "spec" "$wf_file" 2>/dev/null || echo "")
        model=$(get_config_value "model" "$wf_file" 2>/dev/null || echo "")
        output_dir=$(get_config_value "output_dir" "$wf_file" 2>/dev/null || echo "")

        if [[ -n "$readme" && ! -f "$readme" ]]; then
            errors+=("README not found: $readme")
        fi
        if [[ -n "$spec" && ! -f "$spec" ]]; then
            errors+=("Spec not found: $spec")
        fi
        if [[ -z "$model" ]]; then
            errors+=("Model not configured in workflow")
        fi
        if [[ -z "$output_dir" ]]; then
            errors+=("Output directory not configured in workflow")
        fi
    fi

    # Check Oracle
    if ! command -v oracle &>/dev/null && ! command -v npx &>/dev/null; then
        errors+=("Oracle not available")
    fi

    # Check for previous round if not round 1
    if [[ "$round_num" =~ ^[0-9]+$ ]] && [[ "$round_num" -gt 1 ]]; then
        local prev=$((round_num - 1))
        local prev_file="$CONFIG_DIR/rounds/$WORKFLOW/round_${prev}.md"
        if [[ ! -f "$prev_file" ]]; then
            warnings+=("Previous round $prev not found - starting fresh?")
        fi
    fi

    local valid=true
    [[ ${#errors[@]} -gt 0 ]] && valid=false

    local errors_json warnings_json
    errors_json=$(printf '%s\n' "${errors[@]:-}" | jq -Rsc 'split("\n") | map(select(length > 0))')
    warnings_json=$(printf '%s\n' "${warnings[@]:-}" | jq -Rsc 'split("\n") | map(select(length > 0))')

    local data
    data=$(jq -nc \
        --argjson valid "$valid" \
        --argjson errors "$errors_json" \
        --argjson warnings "$warnings_json" \
        --arg workflow "$WORKFLOW" \
        --arg round "$round_num" \
        '{valid: $valid, errors: $errors, warnings: $warnings, workflow: $workflow, round: $round}')

    if [[ "$valid" == "true" ]]; then
        robot_json true "ok" "$data"
    else
        robot_json false "validation_failed" "$data" "Fix errors before running"
        return 1
    fi
}

# Robot: Run - Execute a revision round
robot_run() {
    local round_num="${1:-}"
    local include_impl="${INCLUDE_IMPL:-false}"

    verbose "robot_run: round=$round_num workflow=$WORKFLOW include_impl=$include_impl"

    # First validate
    if [[ -z "$round_num" ]]; then
        robot_json false "missing_argument" '{"argument":"round"}' "Round number required"
        return 1
    fi

    if ! [[ "$round_num" =~ ^[0-9]+$ ]]; then
        robot_json false "invalid_argument" "$(jq -nc --arg round "$round_num" '{argument: "round", value: $round}')" "Round must be a number"
        return 1
    fi

    # Check Oracle
    if ! check_oracle; then
        robot_json false "dependency_missing" '{"dependency":"oracle"}' "Oracle not available"
        return 1
    fi

    # Load workflow config
    local config_path="$CONFIG_DIR/workflows/$WORKFLOW.yaml"
    if [[ ! -f "$config_path" ]]; then
        robot_json false "not_found" "$(jq -nc --arg wf "$WORKFLOW" '{resource: "workflow", name: $wf}')" "Workflow not found"
        return 1
    fi

    # Parse config
    local readme_path spec_path impl_path model output_dir
    readme_path=$(get_config_value "readme" "$config_path" | tr -d '"')
    spec_path=$(get_config_value "spec" "$config_path" | tr -d '"')
    impl_path=$(get_config_value "implementation" "$config_path" | tr -d '"')
    model=$(get_config_value "model" "$config_path" | tr -d '"')
    output_dir=$(get_config_value "output_dir" "$config_path" | tr -d '"')

    # Validate required files
    if [[ ! -f "$readme_path" ]]; then
        robot_json false "not_found" "$(jq -nc --arg f "$readme_path" '{resource: "file", path: $f}')" "README file not found"
        return 1
    fi
    if [[ ! -f "$spec_path" ]]; then
        robot_json false "not_found" "$(jq -nc --arg f "$spec_path" '{resource: "file", path: $f}')" "Spec file not found"
        return 1
    fi

    if [[ "$include_impl" == "true" ]]; then
        if [[ -z "$impl_path" || ! -f "$impl_path" ]]; then
            include_impl=false
        fi
    fi

    # Build session info
    local slug="apr-${WORKFLOW}-round-${round_num}"
    local output_file="${output_dir}/round_${round_num}.md"

    if [[ "$include_impl" == "true" && -n "$impl_path" ]]; then
        slug="${slug}-with-impl"
    fi

    # Build file arguments
    local file_args=(--file "$readme_path")
    if [[ "$include_impl" == "true" && -n "$impl_path" && -f "$impl_path" ]]; then
        file_args+=(--file "$impl_path")
    fi
    file_args+=(--file "$spec_path")

    # Build prompt using shared function
    local prompt
    prompt=$(build_revision_prompt "$include_impl" "$config_path")

    # Create output directory
    mkdir -p "$(dirname "$output_file")" 2>/dev/null

    # Build Oracle command
    local oracle_args=(
        --engine browser
        -m "$model"
        "${file_args[@]}"
        --slug "$slug"
        --write-output "$output_file"
        --files-report
        --notify
        --heartbeat 30
        -p "$prompt"
    )

    verbose "robot_run Oracle command: $ORACLE_CMD ${oracle_args[*]}"
    verbose "robot_run output_file: $output_file"

    # Execute in background
    $ORACLE_CMD "${oracle_args[@]}" &
    local oracle_pid=$!

    # Return session info
    local data
    data=$(jq -nc \
        --arg slug "$slug" \
        --argjson pid "$oracle_pid" \
        --arg output_file "$output_file" \
        --arg workflow "$WORKFLOW" \
        --arg round "$round_num" \
        --argjson include_impl "$include_impl" \
        '{
            slug: $slug,
            pid: $pid,
            output_file: $output_file,
            workflow: $workflow,
            round: ($round | tonumber),
            include_impl: $include_impl,
            status: "running"
        }')

    robot_json true "ok" "$data" "Use 'apr status' or 'apr attach $slug' to monitor"
}

# Robot: History - List revision rounds
robot_history() {
    local rounds_dir="$CONFIG_DIR/rounds/$WORKFLOW"

    if [[ ! -d "$rounds_dir" ]]; then
        robot_json false "not_found" "$(jq -nc --arg wf "$WORKFLOW" '{resource: "rounds", workflow: $wf}')" "No rounds found for workflow"
        return 1
    fi

    local rounds=()
    for round_file in "$rounds_dir"/round_*.md; do
        [[ -f "$round_file" ]] || continue
        local round_num size mod_ts
        round_num=$(basename "$round_file" .md | sed 's/round_//')
        size=$(stat -c '%s' "$round_file" 2>/dev/null || stat -f '%z' "$round_file" 2>/dev/null || echo "0")
        mod_ts=$(stat -c '%Y' "$round_file" 2>/dev/null || stat -f '%m' "$round_file" 2>/dev/null || echo "0")

        rounds+=("$(jq -nc \
            --arg round "$round_num" \
            --arg file "$round_file" \
            --arg size "$size" \
            --arg mod_ts "$mod_ts" \
            '{round: ($round | tonumber), file: $file, size: ($size | tonumber), modified: ($mod_ts | tonumber)}')")
    done

    local rounds_json="[]"
    if [[ ${#rounds[@]} -gt 0 ]]; then
        rounds_json=$(printf '%s\n' "${rounds[@]}" | jq -sc .)
    fi

    local data
    data=$(jq -nc \
        --arg workflow "$WORKFLOW" \
        --argjson count "${#rounds[@]}" \
        --argjson rounds "$rounds_json" \
        '{workflow: $workflow, count: $count, rounds: $rounds}')

    robot_json true "ok" "$data"
}

# Robot: Help - Show robot mode help in JSON
robot_help() {
    local data
    data=$(jq -nc '{
        description: "Robot mode for coding agents - JSON interface to APR",
        usage: "apr robot <command> [args] [options]",
        commands: {
            status: "System overview (config, workflows, oracle)",
            workflows: "List all workflows with descriptions",
            init: "Initialize .apr directory",
            validate: "Pre-run validation (apr robot validate <round>)",
            run: "Execute revision round (apr robot run <round>)",
            history: "List revision rounds for workflow",
            help: "This help"
        },
        options: {
            "-w, --workflow NAME": "Workflow name (default: from config)",
            "-i, --include-impl": "Include implementation document",
            "--compact": "Minified JSON output"
        },
        examples: [
            "apr robot status",
            "apr robot workflows",
            "apr robot validate 1 -w myspec",
            "apr robot run 1",
            "apr robot run 2 -w myspec --include-impl",
            "apr robot history -w myspec"
        ]
    }')

    robot_json true "ok" "$data"
}

# Robot: Main dispatcher
cmd_robot() {
    # shellcheck disable=SC2034  # State flag for helper functions
    ROBOT_MODE=true

    # Check jq is available (required for robot mode)
    if ! command -v jq &>/dev/null; then
        # Output to stdout (not stderr) for consistency with robot mode JSON output
        echo '{"ok":false,"code":"dependency_missing","data":{},"hint":"Robot mode requires jq. Install with: apt install jq","meta":{"v":"'"$VERSION"'"}}'
        exit $EXIT_DEPENDENCY_ERROR
    fi

    # Parse robot-specific options
    local robot_cmd=""
    local robot_args=()

    while [[ $# -gt 0 ]]; do
        case $1 in
            --compact)
                ROBOT_COMPACT=true
                shift
                ;;
            -w|--workflow)
                if [[ -z "${2:-}" ]]; then
                    robot_json false "missing_argument" '{"option":"-w"}' "Option -w requires a workflow name"
                    exit $EXIT_USAGE_ERROR
                fi
                WORKFLOW="$2"
                shift 2
                ;;
            -i|--include-impl)
                INCLUDE_IMPL=true
                shift
                ;;
            -*)
                # Use jq for proper escaping of user input in JSON
                robot_json false "invalid_option" "$(jq -nc --arg opt "$1" '{option: $opt}')" "Unknown option: $1"
                exit $EXIT_USAGE_ERROR
                ;;
            *)
                if [[ -z "$robot_cmd" ]]; then
                    robot_cmd="$1"
                else
                    robot_args+=("$1")
                fi
                shift
                ;;
        esac
    done

    robot_cmd="${robot_cmd:-help}"

    case "$robot_cmd" in
        status)
            robot_status
            ;;
        workflows)
            robot_workflows
            ;;
        init)
            robot_init
            ;;
        validate)
            robot_validate "${robot_args[0]:-}"
            ;;
        run)
            robot_run "${robot_args[0]:-}"
            ;;
        history)
            robot_history
            ;;
        help|--help|-h)
            robot_help
            ;;
        *)
            # Use jq for proper escaping of user input in JSON
            robot_json false "unknown_command" "$(jq -nc --arg cmd "$robot_cmd" '{command: $cmd}')" "Unknown command. Try 'apr robot help'"
            exit $EXIT_USAGE_ERROR
            ;;
    esac
}

# -----------------------------------------------------------------------------
# Help
# -----------------------------------------------------------------------------

show_help() {
    check_gum || true
    print_banner

    if [[ "$GUM_AVAILABLE" == "true" ]]; then
        gum style --foreground 214 --bold "DESCRIPTION" >&2
        gum style --padding "0 2" "Automated Plan Reviser Pro automates iterative specification" >&2
        gum style --padding "0 2" "refinement using GPT Pro Extended Reasoning via Oracle." >&2
        echo "" >&2

        gum style --foreground 214 --bold "SYNOPSIS" >&2
        echo "  apr [command] [options]" >&2
        echo "" >&2

        gum style --foreground 214 --bold "COMMANDS" >&2
        gum style --foreground 39 "  Core Workflow" >&2
        echo "    $(gum style --foreground 82 'run <round>')        Run a revision round" >&2
        echo "    $(gum style --foreground 82 'setup')              Interactive workflow setup wizard" >&2
        echo "    $(gum style --foreground 82 'status')             Check Oracle session status" >&2
        echo "    $(gum style --foreground 82 'attach <session>')   Attach to running/completed session" >&2
        echo "" >&2
        gum style --foreground 39 "  Management" >&2
        echo "    $(gum style --foreground 82 'list')               List configured workflows" >&2
        echo "    $(gum style --foreground 82 'history')            Show revision history" >&2
        echo "    $(gum style --foreground 82 'show <round>')       View round output" >&2
        echo "    $(gum style --foreground 82 'update')             Check for and install updates" >&2
        echo "    $(gum style --foreground 82 'help')               Show this help message" >&2
        echo "" >&2
        gum style --foreground 39 "  Analysis" >&2
        echo "    $(gum style --foreground 82 'diff <N> [M]')       Compare round outputs (N vs M or N vs N-1)" >&2
        echo "    $(gum style --foreground 82 'integrate <round>')  Generate Claude Code integration prompt" >&2
        echo "    $(gum style --foreground 82 'stats')              Show round analytics & convergence signals" >&2
        echo "" >&2
        gum style --foreground 39 "  Automation" >&2
        echo "    $(gum style --foreground 82 'robot')              Machine-friendly CLI for coding agents" >&2
        echo "" >&2

        gum style --foreground 214 --bold "OPTIONS" >&2
        gum style --faint "  -w, --workflow NAME  Workflow to use (default: from config)" >&2
        gum style --faint "  -i, --include-impl   Include implementation document" >&2
        gum style --faint "  -d, --dry-run        Preview without sending to GPT Pro" >&2
        gum style --faint "  -r, --render         Render bundle for manual paste" >&2
        gum style --faint "  -c, --copy           Copy rendered bundle to clipboard" >&2
        gum style --faint "  -o, --output FILE    Output to file (integrate command)" >&2
        gum style --faint "  --wait               Wait for completion (blocking)" >&2
        gum style --faint "  --login              Manual login mode (first-time setup)" >&2
        gum style --faint "  --keep-browser       Keep browser open after completion" >&2
        gum style --faint "  --no-preflight       Skip pre-flight validation checks" >&2
        gum style --faint "  --retry/--no-retry   Enable/disable auto-retry (default: enabled)" >&2
        gum style --faint "  --hours NUM          Status window in hours (default: 72)" >&2
        gum style --faint "  -v, --verbose        Show detailed debug output" >&2
        gum style --faint "  -q, --quiet          Minimal output (errors only)" >&2
        gum style --faint "  --version            Show version" >&2
        echo "" >&2

        gum style --foreground 214 --bold "ENVIRONMENT VARIABLES" >&2
        gum style --faint "  APR_HOME             Data directory (~/.local/share/apr)" >&2
        gum style --faint "  APR_CACHE            Cache directory (~/.cache/apr)" >&2
        gum style --faint "  APR_CHECK_UPDATES    Enable daily update checking (set to 1)" >&2
        gum style --faint "  APR_STATUS_HOURS     Default status time window (default: 72)" >&2
        gum style --faint "  APR_VERBOSE          Enable verbose mode (set to true)" >&2
        gum style --faint "  APR_MAX_RETRIES      Max retry attempts (default: 3)" >&2
        gum style --faint "  APR_INITIAL_BACKOFF  Initial retry backoff in seconds (default: 10)" >&2
        gum style --faint "  APR_NO_GUM           Disable gum even if available" >&2
        gum style --faint "  NO_COLOR             Disable colored output" >&2
        echo "" >&2

        gum style --foreground 214 --bold "EXAMPLES" >&2
        gum style --foreground 39 "  # First-time setup" >&2
        echo "  apr setup" >&2
        echo "" >&2
        gum style --foreground 39 "  # Run revision round 1" >&2
        echo "  apr run 1" >&2
        echo "" >&2
        gum style --foreground 39 "  # Run with implementation doc" >&2
        echo "  apr run 2 --include-impl" >&2
        echo "" >&2
        gum style --foreground 39 "  # First run with manual login" >&2
        echo "  apr run 1 --login --wait" >&2
        echo "" >&2
        gum style --foreground 39 "  # Compare round outputs" >&2
        echo "  apr diff 3 5" >&2
        echo "" >&2
        gum style --foreground 39 "  # Generate Claude Code integration prompt" >&2
        echo "  apr integrate 5 --copy" >&2
        echo "" >&2
        gum style --foreground 39 "  # Check session status" >&2
        echo "  apr status" >&2
        echo "" >&2
        gum style --foreground 39 "  # Robot mode (for coding agents)" >&2
        echo "  apr robot status" >&2
        echo "" >&2

        gum style --foreground 214 --bold "EXIT CODES" >&2
        gum style --faint "  0   Success" >&2
        gum style --faint "  1   Partial failure" >&2
        gum style --faint "  2   Usage error (bad arguments)" >&2
        gum style --faint "  3   Dependency error (missing Oracle)" >&2
        gum style --faint "  4   Configuration error" >&2
        gum style --faint "  10  Network error" >&2
        gum style --faint "  11  Update error" >&2
        echo "" >&2

        gum style --foreground 39 "More info: https://github.com/${REPO_OWNER}/${REPO_NAME}" >&2
    else
        echo -e "${BOLD}${YELLOW}DESCRIPTION${NC}" >&2
        echo "  Automated Plan Reviser Pro automates iterative specification" >&2
        echo "  refinement using GPT Pro Extended Reasoning via Oracle." >&2
        echo "" >&2
        echo -e "${BOLD}${YELLOW}SYNOPSIS${NC}" >&2
        echo "  apr [command] [options]" >&2
        echo "" >&2
        echo -e "${BOLD}${YELLOW}COMMANDS${NC}" >&2
        echo -e "  ${CYAN}Core Workflow${NC}" >&2
        echo -e "    ${GREEN}run <round>${NC}        Run a revision round" >&2
        echo -e "    ${GREEN}setup${NC}              Interactive workflow setup wizard" >&2
        echo -e "    ${GREEN}status${NC}             Check Oracle session status" >&2
        echo -e "    ${GREEN}attach <session>${NC}   Attach to running/completed session" >&2
        echo "" >&2
        echo -e "  ${CYAN}Management${NC}" >&2
        echo -e "    ${GREEN}list${NC}               List configured workflows" >&2
        echo -e "    ${GREEN}history${NC}            Show revision history" >&2
        echo -e "    ${GREEN}show <round>${NC}       View round output" >&2
        echo -e "    ${GREEN}update${NC}             Check for and install updates" >&2
        echo -e "    ${GREEN}help${NC}               Show this help message" >&2
        echo "" >&2
        echo -e "  ${CYAN}Analysis${NC}" >&2
        echo -e "    ${GREEN}diff <N> [M]${NC}       Compare round outputs (N vs M or N vs N-1)" >&2
        echo -e "    ${GREEN}integrate <round>${NC}  Generate Claude Code integration prompt" >&2
        echo -e "    ${GREEN}stats${NC}              Show round analytics & convergence signals" >&2
        echo "" >&2
        echo -e "  ${CYAN}Automation${NC}" >&2
        echo -e "    ${GREEN}robot${NC}              Machine-friendly CLI for coding agents" >&2
        echo "" >&2
        echo -e "${BOLD}${YELLOW}OPTIONS${NC}" >&2
        echo "  -w, --workflow NAME  Workflow to use (default: from config)" >&2
        echo "  -i, --include-impl   Include implementation document" >&2
        echo "  -d, --dry-run        Preview without sending to GPT Pro" >&2
        echo "  -r, --render         Render bundle for manual paste" >&2
        echo "  -c, --copy           Copy rendered bundle to clipboard" >&2
        echo "  -o, --output FILE    Output to file (integrate command)" >&2
        echo "  --wait               Wait for completion (blocking)" >&2
        echo "  --login              Manual login mode (first-time setup)" >&2
        echo "  --keep-browser       Keep browser open after completion" >&2
        echo "  --no-preflight       Skip pre-flight validation checks" >&2
        echo "  --retry/--no-retry   Enable/disable auto-retry (default: enabled)" >&2
        echo "  --hours NUM          Status window in hours (default: 72)" >&2
        echo "  -v, --verbose        Show detailed debug output" >&2
        echo "  -q, --quiet          Minimal output (errors only)" >&2
        echo "  --version            Show version" >&2
        echo "" >&2
        echo -e "${BOLD}${YELLOW}ENVIRONMENT VARIABLES${NC}" >&2
        echo "  APR_HOME             Data directory (~/.local/share/apr)" >&2
        echo "  APR_CACHE            Cache directory (~/.cache/apr)" >&2
        echo "  APR_CHECK_UPDATES    Enable daily update checking (set to 1)" >&2
        echo "  APR_STATUS_HOURS     Default status time window (default: 72)" >&2
        echo "  APR_VERBOSE          Enable verbose mode (set to true)" >&2
        echo "  APR_MAX_RETRIES      Max retry attempts (default: 3)" >&2
        echo "  APR_INITIAL_BACKOFF  Initial retry backoff in seconds (default: 10)" >&2
        echo "  APR_NO_GUM           Disable gum even if available" >&2
        echo "  NO_COLOR             Disable colored output" >&2
        echo "" >&2
        echo -e "${BOLD}${YELLOW}EXAMPLES${NC}" >&2
        echo "  apr setup                    # First-time setup" >&2
        echo "  apr run 1                    # Run revision round 1" >&2
        echo "  apr run 2 --include-impl     # Include implementation doc" >&2
        echo "  apr run 1 --login --wait     # First run with manual login" >&2
        echo "  apr diff 3 5                 # Compare round outputs" >&2
        echo "  apr integrate 5 --copy       # Generate integration prompt" >&2
        echo "  apr status                   # Check session status" >&2
        echo "  apr robot status             # Robot mode (for agents)" >&2
        echo "" >&2
        echo -e "${BOLD}${YELLOW}EXIT CODES${NC}" >&2
        echo "  0   Success" >&2
        echo "  1   Partial failure" >&2
        echo "  2   Usage error (bad arguments)" >&2
        echo "  3   Dependency error (missing Oracle)" >&2
        echo "  4   Configuration error" >&2
        echo "  10  Network error" >&2
        echo "  11  Update error" >&2
        echo "" >&2
        echo -e "${CYAN}More info: https://github.com/${REPO_OWNER}/${REPO_NAME}${NC}" >&2
    fi
}

# -----------------------------------------------------------------------------
# Main
# -----------------------------------------------------------------------------

main() {
    # Handle --version and --help early (before gum/oracle checks)
    if [[ "${1:-}" == "--version" || "${1:-}" == "-V" ]]; then
        echo "apr version $VERSION"
        exit $EXIT_SUCCESS
    fi

    if [[ "${1:-}" == "--help" || "${1:-}" == "-h" ]]; then
        check_gum || true
        show_help
        exit $EXIT_SUCCESS
    fi

    # Check for quiet flag early
    for arg in "$@"; do
        if [[ "$arg" == "-q" || "$arg" == "--quiet" ]]; then
            QUIET_MODE=true
            break
        fi
    done

    # Initialize gum
    check_gum || true

    # Check for updates (opt-in, non-blocking)
    check_for_updates

    # Check Oracle availability (not needed for some commands)
    local command="${1:-help}"

    # First-run experience: if no args and not configured, show welcome
    if [[ "$command" == "help" && ! -d "$CONFIG_DIR" ]]; then
        show_first_run_welcome
        exit $EXIT_SUCCESS
    fi

    # Parse command and options
    shift || true

    # Robot mode handles its own argument parsing
    if [[ "$command" == "robot" ]]; then
        # Initialize workflow variable for robot commands that need it
        WORKFLOW=""
        if [[ -f "$CONFIG_DIR/config.yaml" ]]; then
            WORKFLOW=$(get_config_value "default_workflow" "$CONFIG_DIR/config.yaml" 2>/dev/null || echo "")
        fi
        WORKFLOW="${WORKFLOW:-default}"
        cmd_robot "$@"
        exit $?
    fi

    # Global options
    WORKFLOW=""
    INCLUDE_IMPL=false
    DRY_RUN=false
    RENDER=false
    COPY=false
    WAIT_MODE=false
    MANUAL_LOGIN=false
    KEEP_BROWSER=false
    SKIP_PREFLIGHT=false
    ENABLE_RETRY=true
    INTEGRATE_OUTPUT=""
    STATUS_HOURS="${APR_STATUS_HOURS:-72}"

    local positional_args=()

    while [[ $# -gt 0 ]]; do
        case $1 in
            -w|--workflow)
                if [[ -z "${2:-}" || "$2" == -* ]]; then
                    print_error "Option -w requires a workflow name"
                    exit $EXIT_USAGE_ERROR
                fi
                WORKFLOW="$2"
                shift 2
                ;;
            -i|--include-impl)
                INCLUDE_IMPL=true
                shift
                ;;
            -d|--dry-run)
                DRY_RUN=true
                shift
                ;;
            -r|--render)
                RENDER=true
                shift
                ;;
            -c|--copy)
                COPY=true
                shift
                ;;
            --wait)
                WAIT_MODE=true
                shift
                ;;
            --login)
                MANUAL_LOGIN=true
                shift
                ;;
            --keep-browser)
                KEEP_BROWSER=true
                shift
                ;;
            --no-preflight)
                SKIP_PREFLIGHT=true
                shift
                ;;
            --retry)
                ENABLE_RETRY=true
                shift
                ;;
            --no-retry)
                ENABLE_RETRY=false
                shift
                ;;
            -o|--output)
                if [[ -z "${2:-}" || "$2" == -* ]]; then
                    print_error "Option --output requires a file path"
                    exit $EXIT_USAGE_ERROR
                fi
                INTEGRATE_OUTPUT="$2"
                shift 2
                ;;
            --hours)
                if [[ -z "${2:-}" || "$2" == -* ]]; then
                    print_error "Option --hours requires a number"
                    exit $EXIT_USAGE_ERROR
                fi
                STATUS_HOURS="$2"
                shift 2
                ;;
            -q|--quiet)
                QUIET_MODE=true
                shift
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            --version)
                echo "apr version $VERSION"
                exit $EXIT_SUCCESS
                ;;
            --help|-h)
                show_help
                exit $EXIT_SUCCESS
                ;;
            -*)
                print_error "Unknown option: $1"
                show_help
                exit $EXIT_USAGE_ERROR
                ;;
            *)
                positional_args+=("$1")
                shift
                ;;
        esac
    done

    # Set workflow default
    if [[ -z "$WORKFLOW" && -f "$CONFIG_DIR/config.yaml" ]]; then
        WORKFLOW=$(get_config_value "default_workflow" "$CONFIG_DIR/config.yaml")
    fi
    WORKFLOW="${WORKFLOW:-default}"

    local command_is_round=false
    if [[ "$command" =~ ^[0-9]+$ ]]; then
        command_is_round=true
    fi

    local oracle_required=false
    if [[ "$command_is_round" == "true" || "$command" == "run" ]]; then
        if [[ "$DRY_RUN" == "true" && "$RENDER" != "true" ]]; then
            oracle_required=false
        else
            oracle_required=true
        fi
    elif [[ "$command" == "status" || "$command" == "attach" ]]; then
        oracle_required=true
    fi

    if [[ "$oracle_required" == "true" ]]; then
        if ! check_oracle; then
            print_error "Oracle not found"
            print_info "Install with: npm install -g @steipete/oracle"
            print_info "Or ensure npx is available"
            exit $EXIT_DEPENDENCY_ERROR
        fi
    else
        # Best-effort Oracle detection for dry-run output
        if [[ "$command_is_round" == "true" || "$command" == "run" ]]; then
            if ! check_oracle; then
                ORACLE_CMD="oracle"
                [[ "$QUIET_MODE" != "true" ]] && print_warning "Oracle not found; dry run will use a placeholder command"
            fi
        fi
    fi

    # Execute command
    case "$command" in
        run)
            if [[ ${#positional_args[@]} -lt 1 ]]; then
                print_error "Round number required"
                print_info "Usage: apr run <round_number>"
                exit $EXIT_USAGE_ERROR
            fi
            if [[ ! "${positional_args[0]}" =~ ^[0-9]+$ ]]; then
                print_error "Round number must be a positive integer"
                print_info "Usage: apr run <round_number>"
                exit $EXIT_USAGE_ERROR
            fi
            run_round "${positional_args[0]}"
            ;;
        setup)
            run_setup
            ;;
        status)
            show_status
            ;;
        attach)
            if [[ ${#positional_args[@]} -lt 1 ]]; then
                print_error "Session ID/slug required"
                print_info "Usage: apr attach <session>"
                exit $EXIT_USAGE_ERROR
            fi
            attach_session "${positional_args[0]}"
            ;;
        list)
            list_workflows
            ;;
        history)
            show_history
            ;;
        show)
            if [[ ${#positional_args[@]} -lt 1 ]]; then
                print_error "Round number required"
                print_info "Usage: apr show <round>"
                exit $EXIT_USAGE_ERROR
            fi
            if [[ ! "${positional_args[0]}" =~ ^[0-9]+$ ]]; then
                print_error "Round number must be a positive integer"
                print_info "Usage: apr show <round>"
                exit $EXIT_USAGE_ERROR
            fi
            show_round "${positional_args[0]}"
            ;;
        diff)
            if [[ ${#positional_args[@]} -lt 1 ]]; then
                print_error "At least one round number required"
                print_info "Usage: apr diff <round> [round2]"
                print_info "  apr diff 5      # Compare round 5 with round 4"
                print_info "  apr diff 3 7    # Compare round 3 with round 7"
                exit $EXIT_USAGE_ERROR
            fi
            if [[ ! "${positional_args[0]}" =~ ^[0-9]+$ ]]; then
                print_error "Round number must be a positive integer"
                exit $EXIT_USAGE_ERROR
            fi
            local round_b=""
            if [[ ${#positional_args[@]} -ge 2 ]]; then
                if [[ ! "${positional_args[1]}" =~ ^[0-9]+$ ]]; then
                    print_error "Second round number must be a positive integer"
                    exit $EXIT_USAGE_ERROR
                fi
                round_b="${positional_args[1]}"
            fi
            diff_rounds "${positional_args[0]}" "$round_b"
            ;;
        integrate)
            if [[ ${#positional_args[@]} -lt 1 ]]; then
                print_error "Round number required"
                print_info "Usage: apr integrate <round> [--copy] [--output FILE]"
                exit $EXIT_USAGE_ERROR
            fi
            if [[ ! "${positional_args[0]}" =~ ^[0-9]+$ ]]; then
                print_error "Round number must be a positive integer"
                exit $EXIT_USAGE_ERROR
            fi
            generate_integration "${positional_args[0]}"
            ;;
        stats)
            show_stats
            ;;
        update)
            cmd_update
            ;;
        help|--help|-h)
            show_help
            ;;
        *)
            # If command looks like a number, treat as round number
            if [[ "$command" =~ ^[0-9]+$ ]]; then
                run_round "$command"
            else
                print_error "Unknown command: $command"
                show_help
                exit $EXIT_USAGE_ERROR
            fi
            ;;
    esac
}

main "$@"
